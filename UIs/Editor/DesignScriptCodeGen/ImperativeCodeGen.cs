using System;
using ProtoCore.AST.ImperativeAST;
using System.IO;
using ProtoCore;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ProtoCore.Exceptions;

namespace DesignScript.Editor.CodeGen
{
    class ImperativeCodeGen : CoreCodeGen
    {
        private static int forloopCounter = -1;

        private List<ImperativeNode> astNodes;

        private ProtoCore.DSASM.ImperativeCompilePass compilePass;

        public ImperativeCodeGen(ProtoLanguage.CompileStateTracker compileState, ProtoCore.DSASM.CodeBlock parentBlock = null)
            : base(compileState, parentBlock)
        {
            //  dumpbytecode is optionally enabled
            //
            astNodes = new List<ImperativeNode>();

            SetCompileOptions();

            // Create a new symboltable for this block
            // Set the new symbol table's parent
            // Set the new table as a child of the parent table

            codeBlock = new ProtoCore.DSASM.CodeBlock(
                ProtoCore.DSASM.CodeBlockType.kLanguage,
                ProtoCore.Language.kImperative,
                compileState.CodeBlockIndex,
                new ProtoCore.DSASM.SymbolTable("imperative lang block", compileState.RuntimeTableIndex),
                new ProtoCore.DSASM.ProcedureTable(compileState.RuntimeTableIndex));

            ++compileState.CodeBlockIndex;
            ++compileState.RuntimeTableIndex;

            compileState.CodeBlockList.Add(codeBlock);
            if (null != parentBlock)
            {
                // This is a nested block
                parentBlock.children.Add(codeBlock);
                codeBlock.parent = parentBlock;
            }

            blockScope = 0;
        }

        private void SetCompileOptions()
        {
            // Manually set options
            // This is normally done from a makefile
            ProtoCore.CompilerOptions.optSet = 0;
            ProtoCore.CompilerOptions.optSet |= (int)ProtoCore.CompilerOptions.OptImperative.kAutoAllocate;
        }

        private string GetForCountIdent()
        {
            // TODO Jun: Should this be autogenerated or kept as a constant?
            return ProtoCore.DSASM.Constants.kStartOfAutogenForloopCount + forloopCounter.ToString();
        }

        private string GetForIterationVar()
        {
            // TODO Jun: Should this be autogenerated or kept as a constant?
            return ProtoCore.DSASM.Constants.kStartOfAutogenForloopIteration + forloopCounter.ToString();
        }

        private string GetForExprIdent()
        {
            // TODO Jun: Should this be autogenerated or kept as a constant?
            return ProtoCore.DSASM.Constants.kStartOfAutogenForloopExprIdent + forloopCounter.ToString();
        }

        private bool IsNoValueStatement(ImperativeNode node)
        {
            return (node is IfStmtNode) || (node is ForLoopNode) || (node is WhileStmtNode);
        }

        private int DfsExprValue(ImperativeNode node)
        {
            if (node is IdentifierNode)
            {
                int val = 0;
                IdentifierNode t = node as IdentifierNode;
                try
                {
                    val = System.Convert.ToInt32(t.Value);
                    return val;
                }
                catch (OverflowException)
                {
                }
                catch (FormatException)
                {
                }
            }
            else if (node is BinaryExpressionNode)
            {
                BinaryExpressionNode b = node as BinaryExpressionNode;
                Debug.Assert(ProtoCore.DSASM.Operator.mul == b.Optr);
                int left = DfsExprValue(b.LeftNode);
                int right = DfsExprValue(b.RightNode);
                return left * right;
            }
            return 1;
        }

        private void DfsEmitArraySize(ImperativeNode node)
        {
            // s = size * ( i * j * k..n )
            if (node is ArrayNode)
            {
                ArrayNode array = node as ArrayNode;

                ProtoCore.Type type = new ProtoCore.Type();
                type.UID = (int)ProtoCore.PrimitiveType.kInvalidType;
                type.IsIndexable = false;
                DfsTraverse(array.Expr, ref type);

                if (array.Type is ArrayNode)
                {
                    DfsEmitArraySize(array.Type);
                }
            }
            else
            {
                Debug.Assert(false, "ast error – check ast construction");
            }
        }

        // this method is used in conjuction with array indexing
        private void DfsEmitArrayIndex(ImperativeNode node, int symbolindex, int index = 0)
        {
            // s = b + ((i * i.w) + (j * j.w) + (n * n.w))

            if (node is ArrayNode)
            {
                ArrayNode array = node as ArrayNode;

                ProtoCore.Type type = new ProtoCore.Type();
                type.UID = (int)ProtoCore.PrimitiveType.kTypeVoid;
                type.IsIndexable = false;

                DfsTraverse(array.Expr, ref type);

                // Max size of the current dimension
                int w = codeBlock.symbolTable.symbolList[symbolindex].arraySizeList[index];

                // TODO Jun: Performance improvement
                // Avoid having to generate instructions for the current index if 'w' is 0

                if (array.Type is ArrayNode)
                {
                    DfsEmitArrayIndex(array.Type, symbolindex, index + 1);
                }
            }
            else
            {
                Debug.Assert(false, "ast error – check ast construction");
            }
        }

        // this method is used in conjuction with array var declarations
        private void DfsBuildIndex(ImperativeNode node, List<int> indexlist)
        {
            if (node is ArrayNode)
            {
                ArrayNode array = node as ArrayNode;
                int exprval = 0;
                if (null != array.Expr)
                {
                    exprval = DfsExprValue(array.Expr);
                }
                indexlist.Add(exprval);
                DfsBuildIndex(array.Type, indexlist);
            }
        }

        private void AllocateArray(ProtoCore.DSASM.SymbolNode symbol, ImperativeNode nodeArray)
        {
            symbol.isArray = true;

            //===================================================
            // TODO Jun: 
            //  Determine which is optimal-
            //  1. Storing the array flag in the symbol, or...
            //  2. Storing the array flag as an instruction operand
            //===================================================

            // TODO Jun: allocate to the stack is the array has empty expressions
            ArrayNode array = nodeArray as ArrayNode;
            bool heapAlloc = null != array.Expr;
            symbol.memregion = (true == heapAlloc) ? ProtoCore.DSASM.MemoryRegion.kMemHeap : ProtoCore.DSASM.MemoryRegion.kMemStack;

            if (ProtoCore.DSASM.MemoryRegion.kMemStack == symbol.memregion)
            {
                symbol.arraySizeList = new List<int>();
                List<int> indexlist = new List<int>();

                // TODO Jun: Optimize this
                DfsBuildIndex(nodeArray, indexlist);
                foreach (int indexVal in indexlist)
                {
                    if (0 != indexVal)
                    {
                        symbol.size *= indexVal;
                    }
                }

                // Rebuild the array that is needed to compute the size at each index
                indexlist.RemoveAt(0);
                indexlist.Add(symbol.datasize);

                for (int n = 0; n < indexlist.Count; ++n)
                {
                    symbol.arraySizeList.Add(1);
                    for (int i = n; i < indexlist.Count; ++i)
                    {
                        symbol.arraySizeList[n] *= indexlist[i];
                    }
                }
            }
            else if (ProtoCore.DSASM.MemoryRegion.kMemHeap == symbol.memregion)
            {
            }
            else
            {
                Debug.Assert(false, "Invalid memory region");
            }
            SetStackIndex(symbol);
        }

        private ProtoCore.DSASM.SymbolNode Allocate(
            string ident,
            int funcIndex,
            ProtoCore.Type datatype,
            int size = 1,
            int datasize = (int)ProtoCore.DSASM.Constants.kPrimitiveSize,
            ImperativeNode nodeArray = null,
            ProtoCore.DSASM.MemoryRegion region = ProtoCore.DSASM.MemoryRegion.kMemStack)
        {

            ProtoCore.DSASM.SymbolNode symbolnode = new ProtoCore.DSASM.SymbolNode(
                ident,
                ProtoCore.DSASM.Constants.kInvalidIndex,
                ProtoCore.DSASM.Constants.kInvalidIndex,
                funcIndex,
                datatype,
                compileState.TypeSystem.BuildTypeObject((int)PrimitiveType.kTypeVar, false, - 2),
                size,
                datasize,
                false,
                codeBlock.symbolTable.runtimeIndex,
                region,
                false,
                null,
                globalClassIndex);


            Debug.Assert(ProtoCore.DSASM.Constants.kInvalidIndex == symbolnode.symbolTableIndex);

            if (null == nodeArray)
            {
                AllocateVar(symbolnode);
            }
            else
            {
                AllocateArray(symbolnode, nodeArray);
            }

            int symbolindex = ProtoCore.DSASM.Constants.kInvalidIndex;
            if ((int)ProtoCore.DSASM.Constants.kInvalidIndex != globalClassIndex)
            {
                symbolindex = compileState.ClassTable.ClassNodes[globalClassIndex].symbols.Append(symbolnode);
            }
            else
            {
                symbolindex = codeBlock.symbolTable.Append(symbolnode);
            }


            // TODO Jun: Set the symbol table index of the first local variable of 'funcIndex'
            // This will no longer required once the functiontable is refactored to include a symbol table 
            // if the current codeblock is a while block, the procedureTable will be null
            if (null != localProcedure && null == localProcedure.firstLocal)
            {
                localProcedure.firstLocal = symbolnode.index;
            }

            symbolnode.symbolTableIndex = symbolindex;
            return symbolnode;
        }

        private int AllocateArg(
            string ident,
            int funcIndex,
            ProtoCore.Type datatype,
            int size = 1,
            int datasize = (int)ProtoCore.DSASM.Constants.kPrimitiveSize,
            ImperativeNode nodeArray = null,
            ProtoCore.DSASM.MemoryRegion region = ProtoCore.DSASM.MemoryRegion.kMemStack)
        {
            ProtoCore.DSASM.SymbolNode symbolnode = new ProtoCore.DSASM.SymbolNode(
                ident,
                ProtoCore.DSASM.Constants.kInvalidIndex,
                ProtoCore.DSASM.Constants.kInvalidIndex,
                funcIndex,
                datatype,
                compileState.TypeSystem.BuildTypeObject((int)PrimitiveType.kTypeVar, false, -2),
                size,
                datasize,
                true,
                codeBlock.symbolTable.runtimeIndex,
                region);


            int symbolindex = ProtoCore.DSASM.Constants.kInvalidIndex;
            if (ProtoCore.DSASM.Constants.kInvalidIndex != codeBlock.symbolTable.IndexOf(symbolnode))
            {

            }
            else
            {
                int locOffset = localProcedure.localCount;
                locOffset = localProcedure.localCount;
                symbolnode.index = -1 - ProtoCore.DSASM.StackFrame.kStackFrameSize - (locOffset + argOffset);
                ++argOffset;

                symbolindex = codeBlock.symbolTable.Append(symbolnode);
            }
            return symbolindex;
        }

        private bool IsAssignmentNode(ImperativeNode node)
        {
            if (node is BinaryExpressionNode)
            {
                BinaryExpressionNode b = node as BinaryExpressionNode;
                if (ProtoCore.DSASM.Operator.assign == b.Optr)
                {
                    return false;
                }
            }
            return false;
        }

        // TODO Jun: Merge TraverseFunctionCall with the associative version and implement in a codegen utils file
        //Fuqiang: Cannot merge the two functions. They are different. eg. Associative has "emitReplicationGuide = false;"
        public override void TraverseFunctionCall(ProtoCore.AST.Node node, ProtoCore.AST.Node parentNode, int lefttype, int depth, ref ProtoCore.Type inferedType, ProtoCore.AssociativeGraph.GraphNode graphNode = null, ProtoCore.DSASM.AssociativeSubCompilePass subPass = ProtoCore.DSASM.AssociativeSubCompilePass.kNone)
        {
            Debug.Assert(null == graphNode);

            FunctionCallNode funcCall = node as FunctionCallNode;
            string procName = funcCall.Function.Name;
            List<ProtoCore.Type> arglist = new List<ProtoCore.Type>();
            foreach (ImperativeNode paramNode in funcCall.FormalArguments)
            {
                ProtoCore.Type paramType = new ProtoCore.Type();
                paramType.UID = (int)ProtoCore.PrimitiveType.kTypeVoid;
                paramType.IsIndexable = false;

                // If it's a binary node then continue type check, otherwise disable type check and just take the type of paramNode itself
                // f(1+2.0) -> type check enabled - param is typed as double
                // f(2) -> type check disabled - param is typed as int
                enforceTypeCheck = !(paramNode is BinaryExpressionNode);

                DfsTraverse(paramNode, ref paramType);
                enforceTypeCheck = true;

                arglist.Add(paramType);
            }

            ProtoCore.DSASM.ProcedureNode procNode = null;
            int type = ProtoCore.DSASM.Constants.kInvalidIndex;
            bool isConstructor = false;
            bool isStatic = false;
            bool hasLogError = false;

            int refClassIndex = ProtoCore.DSASM.Constants.kInvalidIndex;
            if (parentNode != null && parentNode is ProtoCore.AST.AssociativeAST.IdentifierListNode)
            {
                ProtoCore.AST.Node leftnode = (parentNode as ProtoCore.AST.AssociativeAST.IdentifierListNode).LeftNode;
                if (leftnode != null && leftnode is ProtoCore.AST.AssociativeAST.IdentifierNode)
                {
                    refClassIndex = compileState.ClassTable.IndexOf(leftnode.Name);
                }
            }

            // If lefttype is a valid class then check if calling a constructor
            if ((int)ProtoCore.PrimitiveType.kInvalidType != inferedType.UID && (int)ProtoCore.PrimitiveType.kTypeVoid != inferedType.UID)
            {
                bool isAccessible;
                int realType;
                if (inferedType.UID > (int)PrimitiveType.kMaxPrimitives)
                {
                    //check if it is function pointer
                    ProtoCore.DSASM.SymbolNode symbolnode = null;
                    bool isAllocated = VerifyAllocation(procName, inferedType.UID, out symbolnode, out isAccessible);
                    if (isAllocated)
                    {
                        procName = ProtoCore.DSASM.Constants.kFunctionPointerCall;
                    }
                }
                if (procName != ProtoCore.DSASM.Constants.kFunctionPointerCall)
                {
                    procNode = compileState.ClassTable.ClassNodes[inferedType.UID].GetMemberFunction(procName, arglist, globalClassIndex, out isAccessible, out realType);

                    if (procNode != null)
                    {
                        Debug.Assert(realType != ProtoCore.DSASM.Constants.kInvalidIndex);
                        isConstructor = procNode.isConstructor;
                        isStatic = procNode.isStatic;
                        type = lefttype = realType;

                        if ((refClassIndex != ProtoCore.DSASM.Constants.kInvalidIndex) && !procNode.isStatic && !procNode.isConstructor)
                        {
                            return;
                        }

                        if (!isAccessible)
                        {
                            type = lefttype = realType;
                            hasLogError = true;
                        }
                    }
                }
            }

            if (!isConstructor && !isStatic && procName != ProtoCore.DSASM.Constants.kFunctionPointerCall)
            {
                //check if it is function pointer
                bool isAccessibleFp;
                ProtoCore.DSASM.SymbolNode symbolnode = null;
                bool isAllocated = VerifyAllocation(procName, globalClassIndex, out symbolnode, out isAccessibleFp);
                if (isAllocated) // not checking the type against function pointer, as the type could be var
                {
                    procName = ProtoCore.DSASM.Constants.kFunctionPointerCall;
                }
                else
                {
                    procNode = compileState.GetFirstVisibleProcedure(procName, arglist, codeBlock);
                    if (null != procNode)
                    {
                        if ((int)ProtoCore.DSASM.Constants.kInvalidIndex != procNode.procId)
                        {
                            // A global function
                            if (compileState.TypeSystem.IsHigherRank((int)procNode.returntype.UID, inferedType.UID))
                            {
                                inferedType = procNode.returntype;
                            }
                        }
                        else
                        {
                            procNode = null;
                        }
                    }
                    else
                    {
                        type = (lefttype != ProtoCore.DSASM.Constants.kInvalidIndex) ? lefttype : globalClassIndex;
                        if (type != ProtoCore.DSASM.Constants.kInvalidIndex)
                        {
                            int realType;
                            bool isAccessible;
                            ProtoCore.DSASM.ProcedureNode memProcNode = compileState.ClassTable.ClassNodes[type].GetMemberFunction(procName, arglist, globalClassIndex, out isAccessible, out realType);

                            if (memProcNode != null)
                            {
                                Debug.Assert(realType != ProtoCore.DSASM.Constants.kInvalidIndex);
                                procNode = memProcNode;
                                inferedType = procNode.returntype;
                                type = realType;

                                if ((refClassIndex != ProtoCore.DSASM.Constants.kInvalidIndex) && !procNode.isStatic && !procNode.isConstructor)
                                {
                                    inferedType.UID = (int)PrimitiveType.kTypeNull;
                                    return;
                                }

                                if (!isAccessible)
                                {
                                    procNode = null;
                                    if (!hasLogError)
                                    {
                                        hasLogError = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (null != procNode)
            {
                //if call is replication call
                if (procNode.isThisCallReplication)
                {
                    inferedType.IsIndexable = true;
                    inferedType.rank++;
                }
            }
            else
            {

                if (depth <= 0 && procName != ProtoCore.DSASM.Constants.kFunctionPointerCall)
                {
                    inferedType.UID = (int)PrimitiveType.kTypeNull;
                }
                else
                {
                    if (procName == ProtoCore.DSASM.Constants.kFunctionPointerCall && depth == 0)
                    {
                        ProtoCore.DSASM.DynamicFunctionNode dynamicFunctionNode = new ProtoCore.DSASM.DynamicFunctionNode(procName, arglist, lefttype);
                        compileState.DynamicFunctionTable.functionTable.Add(dynamicFunctionNode);
                        IdentifierNode iNode = new IdentifierNode()
                        {
                            Value = funcCall.Function.Name,
                            Name = funcCall.Function.Name,
                            datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false)
                        };
                        EmitIdentifierNode(iNode, ref inferedType);
                    }
                    else
                    {
                        ProtoCore.DSASM.DynamicFunctionNode dynamicFunctionNode = new ProtoCore.DSASM.DynamicFunctionNode(funcCall.Function.Name, arglist, lefttype);
                        compileState.DynamicFunctionTable.functionTable.Add(dynamicFunctionNode);
                    }

                    //assign inferedType to var
                    inferedType.UID = (int)PrimitiveType.kTypeVar;
                }
            }
        }

        public int Emit(CodeBlockNode codeblock)
        {
            bool isTopBlock = null == codeBlock.parent;
            if (!isTopBlock)
            {
                // If this is an inner block where there can be no classes, we can start at parsing at the global function state
                compilePass = ProtoCore.DSASM.ImperativeCompilePass.kGlobalFuncSig;
            }

            CodeRangeTable.AddCodeBlockRangeEntry(codeBlock.codeBlockId,
                codeblock.line,
                codeblock.col,
                codeblock.endLine,
                codeblock.endCol,
                compileState.CurrentDSFileName);

            ProtoCore.Type type = new ProtoCore.Type();
            while (ProtoCore.DSASM.ImperativeCompilePass.kDone != compilePass)
            {
                foreach (ImperativeNode node in codeblock.Body)
                {
                    type = new ProtoCore.Type();
                    type.UID = (int)PrimitiveType.kTypeVar;
                    type.IsIndexable = false;
                    DfsTraverse(node, ref type);
                }
                compilePass++;
            }
            compileState.InferedType = type;

            return codeBlock.codeBlockId;
        }

        private void EmitIdentifierNode(ImperativeNode node, ref ProtoCore.Type inferedType, bool isBooleanOp = false)
        {
            IdentifierNode t = node as IdentifierNode;

            int dimensions = 0;

            int runtimeIndex = codeBlock.symbolTable.runtimeIndex;

            ProtoCore.Type type = new ProtoCore.Type();
            type.UID = (int)ProtoCore.PrimitiveType.kTypeVoid;
            type.IsIndexable = false;

            ProtoCore.DSASM.SymbolNode symbolnode = null;
            //bool isAllocated = VerifyAllocation(t.Value, out blockId, out localAllocBlock, out symindex, ref type);
            //bool allocatedLocally = isAllocated && core.runtimeTableIndex == localAllocBlock;
            //bool allocatedExternally = isAllocated && core.runtimeTableIndex > localAllocBlock;
            //bool isVisible = isAllocated && core.runtimeTableIndex >= localAllocBlock;
            bool isAccessible = false;

            if (null == t.ArrayDimensions)
            {
                //check if it is a function instance
                ProtoCore.DSASM.ProcedureNode procNode = null;
                procNode = compileState.GetFirstVisibleProcedure(t.Name, null, codeBlock);
                if (null != procNode)
                {
                    if ((int)ProtoCore.DSASM.Constants.kInvalidIndex != procNode.procId)
                    {
                        // A global function
                        inferedType.IsIndexable = false;
                        inferedType.UID = (int)PrimitiveType.kTypeFunctionPointer;

                        int fptr = compileState.FunctionPointerTable.functionPointerDictionary.Count;
                        ProtoCore.DSASM.FunctionPointerNode fptrNode = new ProtoCore.DSASM.FunctionPointerNode(procNode.procId, procNode.runtimeIndex);
                        compileState.FunctionPointerTable.functionPointerDictionary.TryAdd(fptr, fptrNode);
                        compileState.FunctionPointerTable.functionPointerDictionary.TryGetBySecond(fptrNode, out fptr);

                        return;
                    }
                }
            }

            bool isAllocated = VerifyAllocation(t.Value, globalClassIndex, out symbolnode, out isAccessible);
            if (!isAllocated || !isAccessible)
            {
                inferedType.UID = (int)ProtoCore.PrimitiveType.kTypeNull;
            }
            else
            {
                type = symbolnode.datatype;
                runtimeIndex = symbolnode.runtimeTableIndex;
            }


            if (null != t.ArrayDimensions)
            {
                /* Remove static type checking
                if (!type.IsIndexable && type.UID != (int)PrimitiveType.kTypeArray)
                    buildStatus.LogWarning(ProtoCore.BuildData.WarningID.kWarnMax, string.Format("'{0}' is not indexable at compile time", t.Name));
                */
                dimensions = DfsEmitArrayIndexHeap(t.ArrayDimensions);
            }

            //fix type's rank    
            //fix type's rank   
            if (type.rank >= 0)
            {
                type.rank -= dimensions;
                if (type.rank < 0)
                {
                    //throw new Exception("Exceed maximum rank!");
                    type.rank = 0;
                }
            }

            //check whether the value is an array
            if (type.rank == 0)
            {
                type.IsIndexable = false;
            }

            if (compileState.TypeSystem.IsHigherRank(type.UID, inferedType.UID))
            {
                inferedType = type;
            }
            // We need to get inferedType for boolean variable so that we can perform type check
            inferedType.UID = (isBooleanOp || (type.UID == (int)PrimitiveType.kTypeBool)) ? (int)PrimitiveType.kTypeBool : inferedType.UID;
        }
#if ENABLE_INC_DEC_FIX
        private void EmitPostFixNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            bool parseGlobal = null == localProcedure && ProtoCore.DSASM.ImperativeCompilePass.kAll == compilePass;
            bool parseGlobalFunction = null != localProcedure && ProtoCore.DSASM.ImperativeCompilePass.kGlobalFuncBody == compilePass;

            if (parseGlobal || parseGlobalFunction)
            {
                PostFixNode pfNode = node as PostFixNode;

                //convert post fix operation to a binary operation
                BinaryExpressionNode binRight = new BinaryExpressionNode();
                BinaryExpressionNode bin = new BinaryExpressionNode();

                binRight.LeftNode = pfNode.Identifier;
                binRight.RightNode = new IntNode() { value = "1" };
                binRight.Optr = (ProtoCore.DSASM.UnaryOperator.Increment == pfNode.Operator) ? ProtoCore.DSASM.Operator.add : ProtoCore.DSASM.Operator.sub;
                bin.LeftNode = pfNode.Identifier;
                bin.RightNode = binRight;
                bin.Optr = ProtoCore.DSASM.Operator.assign;
                EmitBinaryExpressionNode(bin, ref inferedType);
            }
        }
#endif
        private void EmitLanguageBlockNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            if (IsParsingGlobal() || IsParsingGlobalFunctionBody())
            {
                LanguageBlockNode langblock = node as LanguageBlockNode;
                //(Fuqiang, Ayush) : Throwing an assert stops NUnit. Negative tests expect to catch a 
                // CompilerException, so we throw that instead.
                //Debug.Assert(ProtoCore.Language.kInvalid != langblock.codeblock.language);

                if (ProtoCore.Language.kInvalid == langblock.codeblock.language)
                {
                    throw new ProtoCore.Exceptions.CompileErrorsOccured("Invalid language block");
                }

                ProtoCore.CompileTime.Context context = new ProtoCore.CompileTime.Context();

                int blockId = ProtoCore.DSASM.Constants.kInvalidIndex;

                if (globalProcIndex != ProtoCore.DSASM.Constants.kInvalidIndex && compileState.ProcNode == null)
                    compileState.ProcNode = codeBlock.procedureTable.procList[globalProcIndex];

                if (langblock.codeblock.language == Language.kAssociative)
                {
                    AssociativeCodeGen codegen = new AssociativeCodeGen(compileState, codeBlock);
                    blockId = codegen.Emit(langblock.CodeBlockNode as ProtoCore.AST.AssociativeAST.CodeBlockNode);
                }
                else if (langblock.codeblock.language == Language.kImperative)
                {
                    ImperativeCodeGen codegen = new ImperativeCodeGen(compileState, codeBlock);
                    blockId = codegen.Emit(langblock.CodeBlockNode as ProtoCore.AST.ImperativeAST.CodeBlockNode);
                }

                //core.Executives[langblock.codeblock.language].Compile(out blockId, codeBlock, langblock.codeblock, context, codeBlock.EventSink, langblock.CodeBlockNode);
                inferedType = compileState.InferedType;

                ExceptionRegistration registration = compileState.ExceptionHandlingManager.ExceptionTable.GetExceptionRegistration(blockId, globalProcIndex, globalClassIndex);
                if (registration == null)
                {
                    registration = compileState.ExceptionHandlingManager.ExceptionTable.Register(blockId, globalProcIndex, globalClassIndex);
                    Debug.Assert(registration != null);
                }
            }
        }

        private void EmitClassDeclNode(ImperativeNode node)
        {
            throw new NotImplementedException();
        }

        private void EmitConstructorDefinitionNode(ImperativeNode node)
        {
            throw new NotImplementedException();
        }

        private void EmitFunctionDefinitionNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            bool parseGlobalFunctionSig = null == localProcedure && ProtoCore.DSASM.ImperativeCompilePass.kGlobalFuncSig == compilePass;
            bool parseGlobalFunctionBody = null == localProcedure && ProtoCore.DSASM.ImperativeCompilePass.kGlobalFuncBody == compilePass;

            FunctionDefinitionNode funcDef = node as FunctionDefinitionNode;
            ProtoCore.DSASM.CodeBlockType originalBlockType = codeBlock.blockType;
            codeBlock.blockType = ProtoCore.DSASM.CodeBlockType.kFunction;
            if (parseGlobalFunctionSig)
            {
                Debug.Assert(null == localProcedure);


                // TODO jun: Add semantics for checking overloads (different parameter types)
                localProcedure = new ProtoCore.DSASM.ProcedureNode();
                localProcedure.name = funcDef.Name;
                localProcedure.localCount = funcDef.localVars;
                localProcedure.returntype.UID = compileState.TypeSystem.GetType(funcDef.ReturnType.Name);
                if (localProcedure.returntype.UID == ProtoCore.DSASM.Constants.kInvalidIndex)
                    localProcedure.returntype.UID = (int)PrimitiveType.kTypeVar;
                localProcedure.returntype.Name = compileState.TypeSystem.GetType(localProcedure.returntype.UID);
                localProcedure.returntype.IsIndexable = funcDef.ReturnType.IsIndexable;
                localProcedure.returntype.rank = funcDef.ReturnType.rank;
                localProcedure.runtimeIndex = codeBlock.codeBlockId;

                globalProcIndex = codeBlock.procedureTable.Append(localProcedure);
                compileState.ProcNode = localProcedure;

                CodeRangeTable.AddCodeBlockFunctionEntry(codeBlock.codeBlockId,
                    globalProcIndex,
                    funcDef.FunctionBody.line,
                    funcDef.FunctionBody.col,
                    funcDef.FunctionBody.endLine,
                    funcDef.FunctionBody.endCol,
                    compileState.CurrentDSFileName);

                // Append arg symbols
                if (null != funcDef.Signature)
                {
                    foreach (VarDeclNode argNode in funcDef.Signature.Arguments)
                    {
                        IdentifierNode paramNode = null;
                        bool aIsDefault = false;
                        ProtoCore.AST.Node aDefaultExpression = null;
                        if (argNode.NameNode is IdentifierNode)
                        {
                            paramNode = argNode.NameNode as IdentifierNode;
                        }
                        else if (argNode.NameNode is BinaryExpressionNode)
                        {
                            BinaryExpressionNode bNode = argNode.NameNode as BinaryExpressionNode;
                            paramNode = bNode.LeftNode as IdentifierNode;
                            aIsDefault = true;
                            aDefaultExpression = bNode;
                            //buildStatus.LogSemanticError("Defualt parameters are not supported");
                            //throw new BuildHaltException();
                        }
                        else
                        {
                            Debug.Assert(false, "Check generated AST");
                        }

                        ProtoCore.Type argType = new ProtoCore.Type();
                        argType.UID = compileState.TypeSystem.GetType(argNode.ArgumentType.Name);
                        if (argType.UID == ProtoCore.DSASM.Constants.kInvalidIndex)
                            argType.UID = (int)PrimitiveType.kTypeVar;
                        argType.Name = compileState.TypeSystem.GetType(argType.UID);
                        argType.IsIndexable = argNode.ArgumentType.IsIndexable;
                        argType.rank = argNode.ArgumentType.rank;
                        int symbolIndex = AllocateArg(paramNode.Value, localProcedure.procId, argType);
                        if (ProtoCore.DSASM.Constants.kInvalidIndex == symbolIndex)
                        {
                            throw new BuildHaltException();
                        }
                        localProcedure.argTypeList.Add(argType);
                        ProtoCore.DSASM.ArgumentInfo argInfo = new ProtoCore.DSASM.ArgumentInfo { isDefault = aIsDefault, defaultExpression = aDefaultExpression, Name = paramNode.Name };
                        localProcedure.argInfoList.Add(argInfo);
                    }
                }

                ExceptionRegistration registration = compileState.ExceptionHandlingManager.ExceptionTable.GetExceptionRegistration(codeBlock.codeBlockId, globalProcIndex, globalClassIndex);
                if (registration == null)
                {
                    registration = compileState.ExceptionHandlingManager.ExceptionTable.Register(codeBlock.codeBlockId, globalProcIndex, globalClassIndex);
                    Debug.Assert(registration != null);
                }
            }
            else if (parseGlobalFunctionBody)
            {
                // Build arglist for comparison
                List<ProtoCore.Type> argList = new List<ProtoCore.Type>();
                if (null != funcDef.Signature)
                {
                    foreach (VarDeclNode argNode in funcDef.Signature.Arguments)
                    {
                        int argType = compileState.TypeSystem.GetType(argNode.ArgumentType.Name);
                        bool isArray = argNode.ArgumentType.IsIndexable;
                        int rank = argNode.ArgumentType.rank;
                        argList.Add(compileState.TypeSystem.BuildTypeObject(argType, isArray, rank));
                    }
                }

                // Get the exisitng procedure that was added on the previous pass
                globalProcIndex = codeBlock.procedureTable.IndexOfExact(funcDef.Name, argList);
                localProcedure = codeBlock.procedureTable.procList[globalProcIndex];


                Debug.Assert(null != localProcedure);

                // Copy the active function to the core so nested language blocks can refer to it
                compileState.ProcNode = localProcedure;

                // Arguments have been allocated, update the baseOffset
                localProcedure.localCount = compileState.BaseOffset;


                ProtoCore.FunctionEndPoint fep = null;

                //Traverse default argument
                foreach (ProtoCore.DSASM.ArgumentInfo argNode in localProcedure.argInfoList)
                {
                    if (!argNode.isDefault)
                    {
                        continue;
                    }
                    BinaryExpressionNode bNode = argNode.defaultExpression as BinaryExpressionNode;
                    // build a temporay node for statement : temp = defaultarg;
                    IdentifierNode iNodeTemp = new IdentifierNode()
                    {
                        Value = ProtoCore.DSASM.Constants.kTempDefaultArg,
                        Name = ProtoCore.DSASM.Constants.kTempDefaultArg,
                        datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false)
                    };
                    BinaryExpressionNode bNodeTemp = new BinaryExpressionNode();
                    bNodeTemp.LeftNode = iNodeTemp;
                    bNodeTemp.Optr = ProtoCore.DSASM.Operator.assign;
                    bNodeTemp.RightNode = bNode.LeftNode;
                    EmitBinaryExpressionNode(bNodeTemp, ref inferedType);
                    ////duild an inline conditional node for statement: defaultarg = (temp == DefaultArgNode) ? defaultValue : temp;
                    //InlineConditionalNode icNode = new InlineConditionalNode();
                    //BinaryExpressionNode cExprNode = new BinaryExpressionNode();
                    //cExprNode.Optr = ProtoCore.DSASM.Operator.eq;
                    //cExprNode.LeftNode = iNodeTemp;
                    //cExprNode.RightNode = new DefaultArgNode();
                    //icNode.ConditionExpression = cExprNode;
                    //icNode.TrueExpression = bNode.RightNode;
                    //icNode.FalseExpression = iNodeTemp;
                    //bNodeTemp.LeftNode = bNode.LeftNode;
                    //bNodeTemp.RightNode = icNode;
                    //EmitBinaryExpressionNode(bNodeTemp, ref inferedType);
                }

                // Traverse definition
                bool hasReturnStatement = false;
                foreach (ImperativeNode bnode in funcDef.FunctionBody.Body)
                {
                    DfsTraverse(bnode, ref inferedType);
                    BinaryExpressionNode binaryNode = bnode as BinaryExpressionNode;
                    hasReturnStatement = hasReturnStatement || ((binaryNode != null) && (binaryNode.LeftNode.Name == ProtoCore.DSDefinitions.Kw.kw_return));
                }

                // All locals have been stack allocated, update the local count of this function
                localProcedure.localCount = compileState.BaseOffset;

                // Update the param stack indices of this function
                foreach (ProtoCore.DSASM.SymbolNode symnode in codeBlock.symbolTable.symbolList.Values)
                {
                    if (symnode.functionIndex == localProcedure.procId && symnode.isArgument)
                    {
                        symnode.index -= localProcedure.localCount;
                    }
                }

                ProtoCore.Lang.JILActivationRecord record = new ProtoCore.Lang.JILActivationRecord();
                record.pc = localProcedure.pc;
                record.locals = localProcedure.localCount;
                record.classIndex = ProtoCore.DSASM.Constants.kInvalidIndex;
                record.funcIndex = localProcedure.procId;
                fep = new ProtoCore.Lang.JILFunctionEndPoint(record);



                // Construct the fep arguments
                fep.FormalParams = new ProtoCore.Type[localProcedure.argTypeList.Count];
                fep.BlockScope = this.codeBlock.codeBlockId;
                localProcedure.argTypeList.CopyTo(fep.FormalParams, 0);

                // TODO Jun: 'classIndexAtCallsite' is the class index as it is stored at the callsite function tables
                // Determine whether this still needs to be aligned to the actual 'classIndex' variable
                // The factors that will affect this is whether the 2 function tables (compiler and callsite) need to be merged
                int classIndexAtCallsite = ProtoCore.DSASM.Constants.kInvalidIndex + 1;
                compileState.FunctionTable.AddFunctionEndPointer(classIndexAtCallsite, funcDef.Name, fep);
                
                //Fuqiang: return is already done in traversing the function body
                //// function return
                //EmitInstrConsole(ProtoCore.DSASM.kw.ret);
                //EmitReturn();
            }

            compileState.ProcNode = localProcedure = null;
            globalProcIndex = ProtoCore.DSASM.Constants.kGlobalScope;
            argOffset = 0;
            compileState.BaseOffset = 0;
            codeBlock.blockType = originalBlockType;
        }

        private void EmitFunctionCallNode(ImperativeNode node, ref ProtoCore.Type inferedType, bool isBooleanOp = false)
        {
            TraverseFunctionCall(node, null, (int)ProtoCore.DSASM.Constants.kInvalidIndex, 0, ref inferedType);
        }

        private void EmitIfStmtNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            if (IsParsingGlobal() || IsParsingGlobalFunctionBody())
            {
                /*
                                def backpatch(bp, pc)
                                    instr = instrstream[bp]
                                    if instr.opcode is jmp
                                        instr.op1 = pc
                                    elseif instr.opcode is cjmp
                                        instr.op2 = pc
                                    end
                                end

                                def backpatch(table, pc)
                                    foreach node in table
                                        backpatch(node.pc, pc)
                                    end
                                end

                */
                /*
                 if(E)		->	traverse E	
                                bpTable = new instance
                                L1 = pc + 1
                                L2 = null 
                                bp = pc
                                emit(jmp, _cx, L1, L2) 
                {
                    S		->	traverse S
                                L1 = null
                                bpTable.append(pc)
                                emit(jmp,labelEnd)
                                backpatch(bp,pc)
                }
                 * */
                // If-expr
                IfStmtNode ifnode = node as IfStmtNode;
                DfsTraverse(ifnode.IfExprNode, ref inferedType);

                // Create a new codeblock for this block
                // Set the current codeblock as the parent of the new codeblock
                // Set the new codeblock as a new child of the current codeblock
                // Set the new codeblock as the current codeblock
                ProtoCore.DSASM.CodeBlock localCodeBlock = new ProtoCore.DSASM.CodeBlock(
                    ProtoCore.DSASM.CodeBlockType.kConstruct,
                    Language.kInvalid,
                    compileState.CodeBlockIndex++,
                    new ProtoCore.DSASM.SymbolTable(GetConstructBlockName("if"), compileState.RuntimeTableIndex++),
                    null);

                localCodeBlock.instrStream = codeBlock.instrStream;
                localCodeBlock.parent = codeBlock;
                codeBlock.children.Add(localCodeBlock);
                codeBlock = localCodeBlock;
                compileState.CodeBlockList.Add(codeBlock);
                CodeRangeTable.AddCodeBlockRangeEntry(codeBlock.codeBlockId,
                    ifnode.IfBodyPosition.line,
                    ifnode.IfBodyPosition.col,
                    ifnode.IfBodyPosition.endLine,
                    ifnode.IfBodyPosition.endCol,
                    compileState.CurrentDSFileName);

                // If-body
                foreach (ImperativeNode ifBody in ifnode.IfBody)
                {
                    inferedType = new ProtoCore.Type();
                    inferedType.UID = (int)PrimitiveType.kTypeVar;
                    DfsTraverse(ifBody, ref inferedType);
                }

                // Restore - Set the local codeblock parent to be the current codeblock
                codeBlock = localCodeBlock.parent;




                /*		
                else if(E)	->	traverse E
                                L1 = pc + 1
                                L2 = null 
                                bp = pc
                                emit(jmp, _cx, L1, L2) 
                {				
                    S		->	traverse S
                                L1 = null
                                bpTable.append(pc)
                                emit(jmp,labelEnd) 
                                backpatch(bp,pc)
                }
                 * */

                // Elseif-expr
                foreach (ElseIfBlock elseifNode in ifnode.ElseIfList)
                {
                    DfsTraverse(elseifNode.Expr, ref inferedType);

                    // Elseif-body   
                    if (null != elseifNode.Body)
                    {
                        // Create a new codeblock for this block
                        // Set the current codeblock as the parent of the new codeblock
                        // Set the new codeblock as a new child of the current codeblock
                        // Set the new codeblock as the current codeblock
                        localCodeBlock = new ProtoCore.DSASM.CodeBlock(
                            ProtoCore.DSASM.CodeBlockType.kConstruct,
                            Language.kInvalid,
                            compileState.CodeBlockIndex++,
                            new ProtoCore.DSASM.SymbolTable(GetConstructBlockName("elseif"), compileState.RuntimeTableIndex++),
                            null);

                        localCodeBlock.instrStream = codeBlock.instrStream;
                        localCodeBlock.parent = codeBlock;
                        codeBlock.children.Add(localCodeBlock);
                        codeBlock = localCodeBlock;
                        compileState.CodeBlockList.Add(codeBlock);
                        CodeRangeTable.AddCodeBlockRangeEntry(codeBlock.codeBlockId,
                            elseifNode.ElseIfBodyPosition.line,
                            elseifNode.ElseIfBodyPosition.col,
                            elseifNode.ElseIfBodyPosition.endLine,
                            elseifNode.ElseIfBodyPosition.endCol,
                            compileState.CurrentDSFileName);

                        foreach (ImperativeNode elseifBody in elseifNode.Body)
                        {
                            inferedType = new ProtoCore.Type();
                            inferedType.UID = (int)PrimitiveType.kTypeVar;
                            DfsTraverse(elseifBody, ref inferedType);
                        }

                        // Restore - Set the local codeblock parent to be the current codeblock
                        codeBlock = localCodeBlock.parent;
                    }
                }

                /*
                else 			
                {				
                    S		->	traverse S
                                L1 = null
                                bpTable.append(pc)
                                emit(jmp,labelEnd) 
                                backpatch(bp,pc)
                }		
                 * */
                // Else-body     

                Debug.Assert(null != ifnode.ElseBody);
                if (0 != ifnode.ElseBody.Count)
                {
                    // Create a new symboltable for this block
                    // Set the current table as the parent of the new table
                    // Set the new table as a new child of the current table
                    // Set the new table as the current table
                    // Create a new codeblock for this block
                    // Set the current codeblock as the parent of the new codeblock
                    // Set the new codeblock as a new child of the current codeblock
                    // Set the new codeblock as the current codeblock
                    localCodeBlock = new ProtoCore.DSASM.CodeBlock(
                        ProtoCore.DSASM.CodeBlockType.kConstruct,
                        Language.kInvalid,
                        compileState.CodeBlockIndex++,
                        new ProtoCore.DSASM.SymbolTable(GetConstructBlockName("else"), compileState.RuntimeTableIndex++),
                        null);

                    localCodeBlock.instrStream = codeBlock.instrStream;
                    localCodeBlock.parent = codeBlock;
                    codeBlock.children.Add(localCodeBlock);
                    codeBlock = localCodeBlock;
                    compileState.CodeBlockList.Add(codeBlock);
                    CodeRangeTable.AddCodeBlockRangeEntry(codeBlock.codeBlockId,
                        ifnode.ElseBodyPosition.line,
                        ifnode.ElseBodyPosition.col,
                        ifnode.ElseBodyPosition.endLine,
                        ifnode.ElseBodyPosition.endCol,
                        compileState.CurrentDSFileName);

                    foreach (ImperativeNode elseBody in ifnode.ElseBody)
                    {
                        inferedType = new ProtoCore.Type();
                        inferedType.UID = (int)PrimitiveType.kTypeVar;
                        DfsTraverse(elseBody, ref inferedType);
                    }

                    // Restore - Set the local codeblock parent to be the current codeblock
                    codeBlock = localCodeBlock.parent;
                }
            }
        }

        private void EmitWhileStmtNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            if (IsParsingGlobal() || IsParsingGlobalFunctionBody())
            {
                WhileStmtNode whileNode = node as WhileStmtNode;
                DfsTraverse(whileNode.Expr, ref inferedType);

                /*
                {
                    S		->	traverse S	
                                bptable.append(pc)
                                emit(jmp, entry) 
                }	
                            ->  backpatch(bp, pc)
                */
                if (null != whileNode.Body)
                {
                    // Create a new symboltable for this block
                    // Set the current table as the parent of the new table
                    // Set the new table as a new child of the current table
                    // Set the new table as the current table
                    // Create a new codeblock for this block
                    // Set the current codeblock as the parent of the new codeblock
                    // Set the new codeblock as a new child of the current codeblock
                    // Set the new codeblock as the current codeblock
                    ProtoCore.DSASM.CodeBlock localCodeBlock = new ProtoCore.DSASM.CodeBlock(
                        ProtoCore.DSASM.CodeBlockType.kConstruct,
                        Language.kInvalid,
                        compileState.CodeBlockIndex++,
                        new ProtoCore.DSASM.SymbolTable(GetConstructBlockName("while"), compileState.RuntimeTableIndex++),
                        null,
                        true);

                    localCodeBlock.instrStream = codeBlock.instrStream;
                    localCodeBlock.parent = codeBlock;
                    codeBlock.children.Add(localCodeBlock);
                    codeBlock = localCodeBlock;
                    compileState.CodeBlockList.Add(codeBlock);
                    CodeRangeTable.AddCodeBlockRangeEntry(codeBlock.codeBlockId,
                        whileNode.line,
                        whileNode.col,
                        whileNode.endLine,
                        whileNode.endCol,
                        compileState.CurrentDSFileName);

                    foreach (ImperativeNode bodyNode in whileNode.Body)
                    {
                        inferedType = new ProtoCore.Type();
                        inferedType.UID = (int)PrimitiveType.kTypeVar;
                        DfsTraverse(bodyNode, ref inferedType);
                    }

                    // Restore - Set the local codeblock parent to be the current codeblock
                    codeBlock = localCodeBlock.parent;

                }
            }
        }

        private void EmitVarDeclNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            VarDeclNode varNode = node as VarDeclNode;

            ProtoCore.Type type = new ProtoCore.Type();
            type.UID = compileState.TypeSystem.GetType(varNode.ArgumentType.Name);
            type.IsIndexable = false;

            // TODO Jun: Create a class table for holding the primitive and custom data types
            const int primitivesize = 1;
            int datasize = primitivesize;

            int symindex = ProtoCore.DSASM.Constants.kInvalidIndex;
            IdentifierNode tVar = null;
            if (varNode.NameNode is IdentifierNode)
            {
                // Allocate with no initializer
                tVar = varNode.NameNode as IdentifierNode;
                ProtoCore.DSASM.SymbolNode symnode = Allocate(tVar.Value, globalProcIndex, type, datasize, datasize, tVar.ArrayDimensions, varNode.memregion);
                IdentLocation.AddEntry(symnode, tVar.line, tVar.col, compileState.CurrentDSFileName);
                symindex = symnode.symbolTableIndex;
            }
            else if (varNode.NameNode is BinaryExpressionNode)
            {
                BinaryExpressionNode bNode = varNode.NameNode as BinaryExpressionNode;
                tVar = bNode.LeftNode as IdentifierNode;

                Debug.Assert(null != tVar, "Check generated AST");
                Debug.Assert(null != bNode.RightNode, "Check generated AST");

                ProtoCore.DSASM.SymbolNode symnode = null;

                // Is it an array
                if (null != tVar.ArrayDimensions)
                {
                    // Allocate an array with initializer
                    if (bNode.RightNode is ExprListNode)
                    {
                        ExprListNode exprlist = bNode.RightNode as ExprListNode;
                        int size = datasize * exprlist.list.Count;

                        symnode = Allocate(tVar.Value, globalProcIndex, type, size, datasize, tVar.ArrayDimensions, varNode.memregion);
                        symindex = symnode.symbolTableIndex;
                        IdentLocation.AddEntry(symnode, tVar.line, tVar.col, compileState.CurrentDSFileName);
                        for (int n = 0; n < exprlist.list.Count; ++n)
                        {
                            DfsTraverse(exprlist.list[n], ref inferedType);

                            IdentifierNode t = new IdentifierNode();
                            t.Value = n.ToString();
                            t.datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeInt, false);

                            ArrayNode array = new ArrayNode();
                            array.Expr = t;
                            array.Type = null;

                            DfsEmitArrayIndex(array, symindex);

                        }
                    }
                }
                else
                {
                    // Allocate a single variable with initializer

                    symnode = Allocate(tVar.Value, globalProcIndex, type, datasize, datasize, tVar.ArrayDimensions, varNode.memregion);
                    IdentLocation.AddEntry(symnode, tVar.line, tVar.col, compileState.CurrentDSFileName);
                    symindex = symnode.symbolTableIndex;
                    DfsTraverse(bNode.RightNode, ref inferedType);
                }
            }
            else
            {
                Debug.Assert(false, "Check generated AST");
            }

            if (ProtoCore.DSASM.Constants.kInvalidIndex == symindex)
            {
                throw new BuildHaltException();
            }
        }

        private void EmitBinaryExpressionNode(ImperativeNode node, ref ProtoCore.Type inferedType, bool isBooleanOp = false)
        {
            if (!IsParsingGlobal() && !IsParsingGlobalFunctionBody())
                return;

            bool isBooleanOperation = false;
            BinaryExpressionNode b = node as BinaryExpressionNode;

            ProtoCore.Type leftType = new ProtoCore.Type();
            leftType.UID = (int)ProtoCore.PrimitiveType.kTypeVar;

            ProtoCore.Type rightType = new ProtoCore.Type();
            rightType.UID = (int)ProtoCore.PrimitiveType.kTypeVar;

            if (ProtoCore.DSASM.Operator.assign != b.Optr)
            {
                isBooleanOperation = ProtoCore.DSASM.Operator.lt == b.Optr
                    || ProtoCore.DSASM.Operator.gt == b.Optr
                    || ProtoCore.DSASM.Operator.le == b.Optr
                    || ProtoCore.DSASM.Operator.ge == b.Optr
                    || ProtoCore.DSASM.Operator.eq == b.Optr
                    || ProtoCore.DSASM.Operator.nq == b.Optr
                    || ProtoCore.DSASM.Operator.and == b.Optr
                    || ProtoCore.DSASM.Operator.or == b.Optr;

                DfsTraverse(b.LeftNode, ref inferedType, isBooleanOperation);

                leftType.UID = inferedType.UID;
                leftType.IsIndexable = inferedType.IsIndexable;
            }

            // (Ayush) in case of PostFixNode, only traverse the identifier now. Post fix operation will be applied later.
#if ENABLE_INC_DEC_FIX
                if (b.RightNode is PostFixNode)
                    DfsTraverse((b.RightNode as PostFixNode).Identifier, ref inferedType, isBooleanOperation);
                else
                {
#endif
            if ((ProtoCore.DSASM.Operator.assign == b.Optr) && (b.RightNode is LanguageBlockNode))
            {
                inferedType.UID = (int)ProtoCore.PrimitiveType.kTypeVar;
                inferedType.IsIndexable = false;
            }
            DfsTraverse(b.RightNode, ref inferedType, isBooleanOperation);
#if ENABLE_INC_DEC_FIX
                }
#endif

            rightType.UID = inferedType.UID;
            rightType.IsIndexable = inferedType.IsIndexable;

            BinaryExpressionNode rightNode = b.RightNode as BinaryExpressionNode;
            if ((rightNode != null) && (ProtoCore.DSASM.Operator.assign == rightNode.Optr))
                DfsTraverse(rightNode.LeftNode, ref inferedType);

            if (b.Optr != ProtoCore.DSASM.Operator.assign)
            {
                isBooleanOp = false;

                //if post fix, now traverse the post fix
#if ENABLE_INC_DEC_FIX
                if (b.RightNode is PostFixNode)
                    EmitPostFixNode(b.RightNode, ref inferedType);
#endif
                return;
            }

            if (b.LeftNode is IdentifierNode)
            {
                IdentifierNode t = b.LeftNode as IdentifierNode;
                ProtoCore.DSASM.SymbolNode symbolnode = null;

                string s = t.Value;
                bool isReturn = (s == ProtoCore.DSDefinitions.Kw.kw_return);
                if (isReturn)
                {
                    EmitReturnStatement(node, inferedType);
                }
                else
                {
                    {
                        // check whether the variable name is a function name
                        bool isAccessibleFp;
                        int realType;
                        ProtoCore.DSASM.ProcedureNode procNode = null;
                        if (globalClassIndex != ProtoCore.DSASM.Constants.kGlobalScope)
                        {
                            procNode = compileState.ClassTable.ClassNodes[globalClassIndex].GetMemberFunction(t.Name, null, globalClassIndex, out isAccessibleFp, out realType);
                        }
                        if (procNode == null)
                        {
                            procNode = compileState.GetFirstVisibleProcedure(t.Name, null, codeBlock);
                        }
                    }

                    bool isAccessible = false;
                    bool isAllocated = VerifyAllocation(t.Value, globalClassIndex, out symbolnode, out isAccessible);
                    int runtimeIndex = (!isAllocated) ? codeBlock.symbolTable.runtimeIndex : symbolnode.runtimeTableIndex;

                    // TODO Jun: Update mechanism work in progress - a flag to manually enable update 
                    bool enableUpdate = false;
                    if (enableUpdate)
                    {
                        bool isExternal = false; // isAllocated && currentLangBlock != codeBlockId;
                        //bool isAssociative = ProtoCore.Language.kAssociative == core.exeList[currentLangBlock].language; 
                        bool isAssociative = false;
                        if (isExternal && isAssociative)
                        {
                            // Check if this is a modifier variable
                            bool isVariableAModifierStack = false;
                            if (isVariableAModifierStack)
                            {
                                // Check if modifying a named modifier state
                                bool isNameModifierState = false;
                                if (isNameModifierState)
                                {
                                    //bool isStateIntermediate = false;

                                }
                                else
                                {

                                }
                                //targetLangBlock = blockId;
                            }
                        }
                    }

                    int dimensions = 0;
                    if (null != t.ArrayDimensions)
                    {
                        dimensions = DfsEmitArrayIndexHeap(t.ArrayDimensions);
                    }

                    ProtoCore.Type castType = compileState.TypeSystem.BuildTypeObject((int)PrimitiveType.kTypeVar, false);
                    var tident = b.LeftNode as TypedIdentifierNode;
                    if (tident != null)
                    {
                        int castUID = tident.datatype.UID;
                        if ((int)PrimitiveType.kInvalidType == castUID)
                        {
                            castUID = compileState.ClassTable.IndexOf(tident.datatype.Name);
                        }

                        if ((int)PrimitiveType.kInvalidType == castUID)
                        {
                            castType = compileState.TypeSystem.BuildTypeObject((int)PrimitiveType.kInvalidType, false);
                            castType.Name = tident.datatype.Name;
                            castType.rank = tident.datatype.rank;
                            castType.IsIndexable = (castType.rank != 0);
                        }
                        else
                        {
                            castType = compileState.TypeSystem.BuildTypeObject(castUID, tident.datatype.IsIndexable, tident.datatype.rank);
                        }
                    }

                    if (globalClassIndex != ProtoCore.DSASM.Constants.kInvalidIndex)
                    {
                        int symbol = ProtoCore.DSASM.Constants.kInvalidIndex;

                        for (int n = 0; n < compileState.ClassTable.ClassNodes[globalClassIndex].symbols.symbolList.Count; ++n)
                        {
                            //Fuqiang: Not a member variable if it is a local variable inside a function with the same name
                            bool localVarInMemFunc = false;
                            if (localProcedure != null)
                            {
                                if (symbolnode == null)
                                {
                                    if (!isAllocated) // if isAllocated, inaccessible member variable 
                                    {
                                        localVarInMemFunc = true;
                                    }
                                }
                                else if (symbolnode.functionIndex != ProtoCore.DSASM.Constants.kGlobalScope && !localProcedure.isConstructor)
                                {
                                    localVarInMemFunc = true;
                                }
                            }
                            bool isMemberVar = ProtoCore.DSASM.Constants.kGlobalScope == compileState.ClassTable.ClassNodes[globalClassIndex].symbols.symbolList[n].functionIndex
                                && compileState.ClassTable.ClassNodes[globalClassIndex].symbols.symbolList[n].name == t.Name
                                && !localVarInMemFunc;
                            if (isMemberVar)
                            {
                                symbol = n;
                                break;
                            }
                        }

                        if (symbol == ProtoCore.DSASM.Constants.kInvalidIndex)
                        {
                            if (!isAllocated)
                            {
                                symbolnode = Allocate(t.Name, globalProcIndex, inferedType);
                                IdentLocation.AddEntry(symbolnode, t.line, t.col, compileState.CurrentDSFileName);
                            }

                            symbol = symbolnode.symbolTableIndex;
                        }

                        if (b.LeftNode is TypedIdentifierNode)
                        {
                            symbolnode.SetStaticType(castType);
                        }
                    }
                    else
                    {
                        if (0 == dimensions)
                        {
                            if (!isAllocated)
                            {
                                symbolnode = Allocate(t.Value, globalProcIndex, inferedType);
                                IdentLocation.AddEntry(symbolnode, t.line, t.col, compileState.CurrentDSFileName);
                            }
                            else
                            {
                                if (compileState.TypeSystem.IsHigherRank(inferedType.UID, symbolnode.datatype.UID))
                                {
                                    symbolnode.datatype = inferedType;
                                }
                            }

                            if (b.LeftNode is TypedIdentifierNode)
                            {
                                symbolnode.SetStaticType(castType);
                            }
                        }
                    }
                }
            }
            else if (b.LeftNode is IdentifierListNode)
            {
                int depth = 0;

                ProtoCore.Type lastType = new ProtoCore.Type();
                lastType.UID = (int)PrimitiveType.kInvalidType;
                lastType.IsIndexable = false;

                bool isFirstIdent = false;
                bool isIdentReference = DfsEmitIdentList(b.LeftNode, b, globalClassIndex, ref lastType, ref depth, ref inferedType, true, ref isFirstIdent);
                inferedType.UID = isBooleanOp ? (int)PrimitiveType.kTypeBool : inferedType.UID;
            }

            //if post fix, now traverse the post fix
#if ENABLE_INC_DEC_FIX
                if (b.RightNode is PostFixNode)
                    EmitPostFixNode(b.RightNode, ref inferedType);
#endif
        }

        private void EmitUnaryExpressionNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            if (IsParsingGlobal() || IsParsingGlobalFunctionBody())
            {
                UnaryExpressionNode u = node as UnaryExpressionNode;
                bool isPrefixOperation = ProtoCore.DSASM.UnaryOperator.Increment == u.Operator || ProtoCore.DSASM.UnaryOperator.Decrement == u.Operator;
                //(Ayush) In case of prefix, apply prefix operation first
                if (isPrefixOperation)
                {
                    if (u.Expression is IdentifierListNode || u.Expression is IdentifierNode)
                    {
                        BinaryExpressionNode binRight = new BinaryExpressionNode();
                        BinaryExpressionNode bin = new BinaryExpressionNode();
                        binRight.LeftNode = u.Expression;
                        binRight.RightNode = new IntNode() { value = "1" };
                        binRight.Optr = (ProtoCore.DSASM.UnaryOperator.Increment == u.Operator) ? ProtoCore.DSASM.Operator.add : ProtoCore.DSASM.Operator.sub;
                        bin.LeftNode = u.Expression; bin.RightNode = binRight; bin.Optr = ProtoCore.DSASM.Operator.assign;
                        EmitBinaryExpressionNode(bin, ref inferedType);
                    }
                    else
                        throw new BuildHaltException("Invalid use of prefix operation.");
                }

                DfsTraverse(u.Expression, ref inferedType);
            }
        }

        private void EmitForLoopNode(ImperativeNode node)
        {
            if (IsParsingGlobal() || IsParsingGlobalFunctionBody())
            {
                /*
                 *
                x = 0;
                a = {10,20,30,40}
                for(val in a)
                {
                    x = x + val;
                }

                Compiles down to:

                x = 0;
                a = {10,20,30,40};
                val = null;
                __autogen_count = 0;
                __autogen_iterations = a.size;
                while( __autogen_count < __autogen_iterations)
                {
                    val = a[__autogen_count];
                    __autogen_count = __autogen_count + 1;
                    x = x + val;
                }
                
                */

                // TODO Jun: This compilation unit has many opportunities for optimization 
                //      1. Compiling to while need not be necessary if 'expr' has exactly one element
                //      2. For-loop can have its own semantics without the need to convert to a while node

                ForLoopNode forNode = node as ForLoopNode;
                ++forloopCounter;   //new forloop beginning. increment loop counter 

                // Generate the expression for ‘id’ initialized to null
                BinaryExpressionNode forIdentInit = new BinaryExpressionNode();
                forIdentInit.Optr = ProtoCore.DSASM.Operator.assign;
                IdentifierNode forIdent = new IdentifierNode()
                {
                    Value = forNode.loopVar.Name,
                    Name = forNode.loopVar.Name,
                    datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false),
                    line = forNode.loopVar.line,
                    col = forNode.loopVar.col,
                    endLine = forNode.loopVar.line,
                    endCol = forNode.loopVar.col + forNode.loopVar.Name.Length - 1
                };

                forIdentInit.LeftNode = forIdent;
                forIdentInit.RightNode = new NullNode();

                ProtoCore.Type type = new ProtoCore.Type();
                type.UID = (int)PrimitiveType.kTypeVoid;
                type.IsIndexable = false;

                forIdentInit.line = forNode.KwForLine;
                forIdentInit.col = forNode.KwForCol;
                forIdentInit.endLine = forNode.KwForLine;
                forIdentInit.endCol = forNode.KwForCol + 2;

                EmitBinaryExpressionNode(forIdentInit, ref type);


                // Generate the expression for autogen counter initialized to 0 
                string forCountIdent = GetForCountIdent();
                IdentifierNode nodeCounter = new IdentifierNode()
                {
                    Value = forCountIdent,
                    Name = forCountIdent,
                    datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false)
                };

                BinaryExpressionNode forcounterExpr = new BinaryExpressionNode();
                forcounterExpr.Optr = ProtoCore.DSASM.Operator.assign;
                forcounterExpr.LeftNode = nodeCounter;
                forcounterExpr.RightNode = new IntNode() { value = "0" };

                type.UID = (int)ProtoCore.PrimitiveType.kTypeVoid;
                EmitBinaryExpressionNode(forcounterExpr, ref type);



                // Generate the expression for autogen iterations initialized to 0 
                string forIterCountVar = GetForIterationVar();
                IdentifierNode nodeIterCount = new IdentifierNode()
                {
                    Value = forIterCountVar,
                    Name = forIterCountVar,
                    datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false)
                };

                BinaryExpressionNode forIterations = new BinaryExpressionNode();
                forIterations.Optr = ProtoCore.DSASM.Operator.assign;
                forIterations.LeftNode = nodeIterCount;
                forIterations.RightNode = new IntNode() { value = "0" };

                type.UID = (int)ProtoCore.PrimitiveType.kTypeVoid;
                EmitBinaryExpressionNode(forIterations, ref type);


                /*
                                // Generate the expression for autogen iteration count assigned to the size of ‘expr’
                                string identName = null;
                                IdentifierNode exprIdent = null;
                                if (forNode.expression is IdentifierNode)
                                {
                                    exprIdent = forNode.expression as IdentifierNode;
                                    identName = exprIdent.Value;
                                }
                                else if (forNode.expression is ExprListNode)
                                {
                                    // Create a temp array variable if 'expr' is an array
                                    identName = GetForExprIdent();
                                    exprIdent = new IdentifierNode()
                                    {
                                        Value = identName,
                                        Name = identName,
                                        type = (int)ProtoCore.PrimitiveType.kTypeVar,
                                        datatype = ProtoCore.PrimitiveType.kTypeVar
                                    };

                                    BinaryExpressionNode arrayexprAssignment = new BinaryExpressionNode();
                                    arrayexprAssignment.Optr = ProtoCore.DSASM.Operator.assign;
                                    arrayexprAssignment.LeftNode = exprIdent;
                                    arrayexprAssignment.RightNode = forNode.expression as ExprListNode; 
                    
                                    type = (int)ProtoCore.PrimitiveType.kTypeVoid;
                                    EmitBinaryExpressionNode(arrayexprAssignment, ref type);
                                }
                                */

                // Generate the expression for autogen iteration count assigned to the size of ‘expr’

                // Create a temp array variable if 'expr' is an array
                string identName = GetForExprIdent();
                IdentifierNode exprIdent = new IdentifierNode()
                {
                    Value = identName,
                    Name = identName,
                    datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false)
                };

                BinaryExpressionNode arrayexprAssignment = new BinaryExpressionNode();
                arrayexprAssignment.Optr = ProtoCore.DSASM.Operator.assign;
                arrayexprAssignment.LeftNode = exprIdent;
                arrayexprAssignment.RightNode = forNode.expression;

                arrayexprAssignment.line = forNode.expression.line;
                arrayexprAssignment.col = forNode.expression.col;
                arrayexprAssignment.endLine = forNode.expression.endLine;
                arrayexprAssignment.endCol = forNode.expression.endCol;

                type.UID = (int)ProtoCore.PrimitiveType.kTypeVoid;
                EmitBinaryExpressionNode(arrayexprAssignment, ref type);

                // Comment Jun: Compile such that the the forloop 'expr' is always assumed to be an array
                // If it was passed a singleton, the runtime will handle it accordingly

                ////if ((int)PrimitiveType.kTypeArray != type)
                //if (false)
                //{

                //    // 'expr' is not an array so it can be assigned directly to 'id'
                //    BinaryExpressionNode exprToIdent = new BinaryExpressionNode();
                //    exprToIdent.Optr = ProtoCore.DSASM.Operator.assign;
                //    exprToIdent.LeftNode = forIdent;
                //    exprToIdent.RightNode = forNode.expression;

                //    forNode.body.Insert(0, exprToIdent);

                //    // There is no loop since 'expr' is a single element. Traverse the for loop body directly
                //    type = (int)ProtoCore.PrimitiveType.kTypeVoid;
                //    if (null != forNode.body)
                //    {
                //        foreach (ImperativeNode bodyNode in forNode.body)
                //        {
                //            DfsTraverse(bodyNode, ref type);
                //        }
                //    }
                //}
                //else
                //{
                // 'expr' is an array

                // Get the size of expr and assign it to the autogen iteration var
                int symbol = ProtoCore.DSASM.Constants.kInvalidIndex;
                if (ProtoCore.DSASM.Constants.kInvalidIndex != globalClassIndex)
                {
                    symbol = compileState.ClassTable.ClassNodes[globalClassIndex].symbols.IndexOf(identName);
                }
                else
                {
                    symbol = codeBlock.symbolTable.IndexOf(identName);
                }



                // Generate the comparison expression between the autogen counter and the autogen iteration count
                BinaryExpressionNode iterCondition = new BinaryExpressionNode();
                iterCondition.Optr = ProtoCore.DSASM.Operator.lt;
                iterCondition.LeftNode = nodeCounter;
                iterCondition.RightNode = nodeIterCount;

                iterCondition.line = forNode.KwInLine;
                iterCondition.col = forNode.KwInCol;
                iterCondition.endLine = forNode.KwInLine;
                iterCondition.endCol = forNode.KwInCol + 1;

                // Generate the assignment statement from where lhs is ‘id’ and rhs is ‘expr’ indexed into the autogen count
                BinaryExpressionNode IndexedExprToId = new BinaryExpressionNode();
                IndexedExprToId.Optr = ProtoCore.DSASM.Operator.assign;
                IndexedExprToId.LeftNode = forIdent;

                // Array index into the expr ident
                ArrayNode arrayIndex = new ArrayNode();
                arrayIndex.Expr = nodeCounter;
                arrayIndex.Type = null;
                exprIdent.ArrayDimensions = arrayIndex;

                IndexedExprToId.RightNode = exprIdent;

                IndexedExprToId.line = forIdent.line;
                IndexedExprToId.col = forIdent.col;
                IndexedExprToId.endLine = forIdent.endLine;
                IndexedExprToId.endCol = forIdent.endCol;

                // Generate the expression for increment by 1 of the autogen count
                BinaryExpressionNode countIncrement = new BinaryExpressionNode();
                countIncrement.Optr = ProtoCore.DSASM.Operator.add;
                countIncrement.LeftNode = nodeCounter;
                countIncrement.RightNode = new IntNode() { value = "1" };

                BinaryExpressionNode countIncrementAssign = new BinaryExpressionNode();
                countIncrementAssign.Optr = ProtoCore.DSASM.Operator.assign;
                countIncrementAssign.LeftNode = nodeCounter;
                countIncrementAssign.RightNode = countIncrement;


                // Append the array indexing and increment expressions into the for-loop body
                forNode.body.Insert(0, IndexedExprToId);
                forNode.body.Insert(1, countIncrementAssign);


                // Construct and populate the equivalent while node
                WhileStmtNode whileNode = new WhileStmtNode();
                whileNode.Expr = iterCondition;
                whileNode.Body = forNode.body;
                whileNode.line = forNode.line;
                whileNode.col = forNode.col;
                whileNode.endLine = forNode.endLine;
                whileNode.endCol = forNode.endCol;

                type.UID = (int)ProtoCore.PrimitiveType.kTypeVoid;
                EmitWhileStmtNode(whileNode, ref type);
                //}

                // Comment Jun: The for loop counter must be unique and does not need to reset
                //forloopCounter--;   //for loop ended. decrement counter 
            }
        }

        private void EmitInlineConditionalNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            InlineConditionalNode inlineConNode = node as InlineConditionalNode;
            IfStmtNode ifNode = new IfStmtNode();
            ifNode.IfExprNode = inlineConNode.ConditionExpression;
            List<ImperativeNode> trueBody = new List<ImperativeNode>();
            trueBody.Add(inlineConNode.TrueExpression);
            List<ImperativeNode> falseBody = new List<ImperativeNode>();
            falseBody.Add(inlineConNode.FalseExpression);
            ifNode.IfBody = trueBody;
            ifNode.ElseBody = falseBody;

            EmitIfStmtNode(ifNode, ref inferedType);
        }

        private void EmitRangeExprNode(ImperativeNode node, ref ProtoCore.Type inferedType)
        {
            // (Ayush) Using Decimal type instead of Double for the sake of precision. For eg. doing 0.3d - 0.1d gives a result a little less than 0.2. These inaccuracies propogate
            // through a range expression and quickly cause wrong values to be returned.
            // TODO: Revert to using double, and use extension methods to compare with tolerance

            RangeExprNode range = node as RangeExprNode;

            if ((range.FromNode is NullNode || range.FromNode is BooleanNode)
                 || (range.ToNode is NullNode || range.ToNode is BooleanNode)
                 || (range.StepNode is NullNode || range.StepNode is BooleanNode))
            {
                throw new ProtoCore.Exceptions.CompileErrorsOccured("Invalid range expression");
            }
            else if ((range.FromNode is IntNode || range.FromNode is DoubleNode)
                && (range.ToNode is IntNode || range.ToNode is DoubleNode)
                && (range.StepNode is IntNode || range.StepNode is DoubleNode))
            {
                ProtoCore.Type type = new ProtoCore.Type();
                type.UID = (int)PrimitiveType.kTypeVoid;
                type.IsIndexable = true;
                type.Name = "double";
                type.UID = (int)PrimitiveType.kTypeDouble;
                type.rank = 1;

                int totalSteps = 0;
                bool terminate = false;
                decimal current = (range.FromNode is IntNode) ? Int64.Parse((range.FromNode as IntNode).value) : Decimal.Parse((range.FromNode as DoubleNode).value);
                decimal end = (range.ToNode is IntNode) ? Int64.Parse((range.ToNode as IntNode).value) : Decimal.Parse((range.ToNode as DoubleNode).value);
                ProtoCore.DSASM.RangeStepOperator stepoperator = range.stepoperator;
                decimal step = (range.StepNode is IntNode) ? Int64.Parse((range.StepNode as IntNode).value) : Decimal.Parse((range.StepNode as DoubleNode).value);
                decimal stepsize = 1.0M;

                if (stepoperator == ProtoCore.DSASM.RangeStepOperator.stepsize)
                {
                    if (step == 0)
                    {
                        EmitNullNode(new NullNode(), ref inferedType);
                        return;
                    }
                    if ((end > current && step < 0) || (end < current && step > 0))
                    {
                        EmitNullNode(new NullNode(), ref inferedType);
                        return;
                    }
                    stepsize = step;
                }
                else if (stepoperator == ProtoCore.DSASM.RangeStepOperator.num)
                {
                    if (!(range.StepNode is IntNode))
                    {
                        EmitNullNode(new NullNode(), ref inferedType);
                        return;
                    }

                    if (step <= 0)
                    {
                        EmitNullNode(new NullNode(), ref inferedType);
                        return;
                    }
                    if ((step - 1) == 0)
                        stepsize = 0;
                    else
                        stepsize = (end - current) / (step - 1);
                }
                else if (stepoperator == ProtoCore.DSASM.RangeStepOperator.approxsize)
                {
                    if (step == 0)
                    {
                        EmitNullNode(new NullNode(), ref inferedType);
                        return;
                    }
                    RangeExprNode rnode = range;
                    IntNode newStep = new IntNode();
                    rnode.StepNode = newStep; rnode.stepoperator = ProtoCore.DSASM.RangeStepOperator.num;

                    decimal dist = end - current;
                    if (dist == 0)
                    {
                        newStep.value = "1";
                    }
                    else
                    {
                        decimal ceilStepSize = Math.Ceiling((dist) / step);
                        decimal floorStepSize = Math.Floor((dist) / step);
                        decimal numOfSteps;

                        if ((ceilStepSize == 0) || (floorStepSize == 0))
                            numOfSteps = 2;
                        else
                            numOfSteps = (Math.Abs(dist / ceilStepSize - step) < Math.Abs(dist / floorStepSize - step)) ? ceilStepSize + 1 : floorStepSize + 1;
                        newStep.value = numOfSteps.ToString();
                    }

                    EmitRangeExprNode(rnode, ref inferedType);
                    return;
                }

                bool isIntArray = (range.FromNode is IntNode) &&
                                  (range.ToNode is IntNode) &&
                                  (range.StepNode is IntNode) &&
                                  (Math.Equals(stepsize, Math.Truncate(stepsize)));
                if (isIntArray)
                {
                    type.Name = "int";
                    type.UID = (int)ProtoCore.PrimitiveType.kTypeInt;
                }

                if (stepsize == 0)
                {
                    for (int i = 0; i < step; ++i)
                    {
                        if (isIntArray)
                            EmitIntNode(new IntNode { value = current.ToString() }, ref type);
                        else
                            EmitDoubleNode(new DoubleNode { value = current.ToString() }, ref type);
                        ++totalSteps;
                    }
                }
                else
                {
                    while (true)
                    {
                        if (stepoperator == ProtoCore.DSASM.RangeStepOperator.stepsize)
                            terminate = (step < 0) ? ((current < end) ? true : false) : ((current > end) ? true : false);
                        else if (stepoperator == ProtoCore.DSASM.RangeStepOperator.num)
                            terminate = (totalSteps >= step) ? true : false;
                        if (terminate) break;

                        if (isIntArray)
                            EmitIntNode(new IntNode { value = current.ToString() }, ref type);
                        else
                            EmitDoubleNode(new DoubleNode { value = current.ToString() }, ref type);

                        current += stepsize;
                        ++totalSteps;
                    }
                }
                inferedType = type;
            }
            else
            {
                //traverse the from node
                DfsTraverse(range.FromNode, ref inferedType);


                //traverse the To node
                DfsTraverse(range.ToNode, ref inferedType);

                //traverse the step node
                DfsTraverse(range.StepNode, ref inferedType);

                inferedType.IsIndexable = true;
                inferedType.rank++;
            }

        }

        private void EmitBreakNode(ProtoCore.AST.Node node)
        {
            ProtoCore.DSASM.CodeBlock breakableCodeBlock = codeBlock;
            while ((breakableCodeBlock != null) && (!breakableCodeBlock.isBreakable))
                breakableCodeBlock = breakableCodeBlock.parent;
        }

        private void EmitContinueNode(ProtoCore.AST.Node node)
        {
            ProtoCore.DSASM.CodeBlock breakableCodeBlock = codeBlock;
            while ((breakableCodeBlock != null) && (!breakableCodeBlock.isBreakable))
                breakableCodeBlock = breakableCodeBlock.parent;
        }

        protected void EmitExceptionHandlingNode(ProtoCore.AST.Node node, ProtoCore.AssociativeGraph.GraphNode graphNode = null, ProtoCore.DSASM.AssociativeSubCompilePass subPass = ProtoCore.DSASM.AssociativeSubCompilePass.kNone)
        {
            if (!IsParsingGlobal() && !IsParsingGlobalFunctionBody())
            {
                return;
            }

            ExceptionHandlingNode exceptionNode = node as ExceptionHandlingNode;
            if (exceptionNode == null)
                return;

            ExceptionRegistration registration = compileState.ExceptionHandlingManager.ExceptionTable.GetExceptionRegistration(codeBlock.codeBlockId, globalProcIndex, globalClassIndex);
            if (registration == null)
            {
                registration = compileState.ExceptionHandlingManager.ExceptionTable.Register(codeBlock.codeBlockId, globalProcIndex, globalClassIndex);
                Debug.Assert(registration != null);
            }

            tryLevel++;

            ExceptionHandler exceptionHandler = new ExceptionHandler();
            exceptionHandler.TryLevel = tryLevel;
            registration.Add(exceptionHandler);
            TryBlockNode tryNode = exceptionNode.tryBlock;
            Debug.Assert(tryNode != null);
            foreach (var subnode in tryNode.body)
            {
                ProtoCore.Type inferedType = new ProtoCore.Type();
                inferedType.UID = (int)ProtoCore.PrimitiveType.kTypeVar;
                inferedType.IsIndexable = false;
                DfsTraverse(subnode, ref inferedType, false, graphNode, subPass);
            }

            // Jmp to code after catch block

            foreach (var catchBlock in exceptionNode.catchBlocks)
            {
                CatchHandler catchHandler = new CatchHandler();
                exceptionHandler.AddCatchHandler(catchHandler);

                CatchFilterNode filterNode = catchBlock.catchFilter;
                Debug.Assert(filterNode != null);
                catchHandler.FilterTypeUID = compileState.TypeSystem.GetType(filterNode.type.Name);

                // For filter expression catch(e:int), generate an assignment
                //    e = %tmpExp;
                BinaryExpressionNode exceptionAssignmentNode = new BinaryExpressionNode()
                {
                    LeftNode = filterNode.var,
                    Optr = ProtoCore.DSASM.Operator.assign,
                    RightNode = new IdentifierNode()
                    {
                        Name = ProtoCore.DSASM.Constants.kTempExceptionVar,
                        Value = ProtoCore.DSASM.Constants.kTempExceptionVar,
                        datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false),
                    }
                };
                ProtoCore.Type inferedType = new ProtoCore.Type();
                inferedType.UID = (int)ProtoCore.PrimitiveType.kTypeVar;
                inferedType.IsIndexable = false;
                DfsTraverse(exceptionAssignmentNode, ref inferedType, false, graphNode, subPass);

                foreach (var subnode in catchBlock.body)
                {
                    inferedType.UID = (int)ProtoCore.PrimitiveType.kTypeVar;
                    inferedType.IsIndexable = false;
                    DfsTraverse(subnode, ref inferedType, false, graphNode, subPass);
                }

                // Jmp to code after catch block
            }

            tryLevel--;
        }

        protected void EmitThrowNode(ProtoCore.AST.Node node, ProtoCore.AssociativeGraph.GraphNode graphNode = null, ProtoCore.DSASM.AssociativeSubCompilePass subPass = ProtoCore.DSASM.AssociativeSubCompilePass.kNone)
        {
            if (!IsParsingGlobal() && !IsParsingGlobalFunctionBody())
            {
                return;
            }

            ThrowNode throwNode = node as ThrowNode;
            if (throwNode == null)
            {
                return;
            }

            BinaryExpressionNode tempAssignmentNode = new BinaryExpressionNode()
            {
                LeftNode = new IdentifierNode()
                {
                    Name = ProtoCore.DSASM.Constants.kTempExceptionVar,
                    Value = ProtoCore.DSASM.Constants.kTempExceptionVar,
                    datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false),
                },
                Optr = ProtoCore.DSASM.Operator.assign,
                RightNode = throwNode.expression
            };

            ProtoCore.Type inferedType = new ProtoCore.Type();
            inferedType.UID = (int)ProtoCore.PrimitiveType.kTypeVar;
            inferedType.IsIndexable = false;
            DfsTraverse(tempAssignmentNode, ref inferedType, false, graphNode, subPass);
        }

        protected FunctionCallNode EmitGetterSetterForIdent(IdentifierNode inode, bool isSetter = false)
        {
            if (isSetter)
            {
                FunctionCallNode setter = new FunctionCallNode();
                setter.Function = inode;

                IdentifierNode tmpArg = new IdentifierNode();
                tmpArg.Name = tmpArg.Value = ProtoCore.DSASM.Constants.kTempArg;
                tmpArg.datatype = compileState.TypeSystem.BuildTypeObject(PrimitiveType.kTypeVar, false);
                setter.FormalArguments.Add(tmpArg);

                return setter;
            }
            else
            {
                FunctionCallNode getter = new FunctionCallNode();
                getter.Function = inode;
                return getter;
            }
        }

        protected void EmitGetterSetterForIdentList(ProtoCore.AST.Node node, bool isSetter = false)
        {
            IdentifierListNode inode = node as IdentifierListNode;
            if (isSetter && inode != null)
            {
                // replace right-most property with setter
                if (inode.RightNode is IdentifierNode)
                {
                    FunctionCallNode setter = EmitGetterSetterForIdent(inode.RightNode as IdentifierNode, true);
                    inode.RightNode = setter;
                }
                if (inode.LeftNode is IdentifierNode)
                {
                    FunctionCallNode getter = EmitGetterSetterForIdent(inode.LeftNode as IdentifierNode, false);
                    inode.LeftNode = getter;
                    return;
                }
                inode = inode.LeftNode as IdentifierListNode;
            }

            while (inode != null)
            {
                if (inode.RightNode is IdentifierNode)
                {
                    FunctionCallNode getter = EmitGetterSetterForIdent(inode.RightNode as IdentifierNode, false);
                    inode.RightNode = getter;
                }

                if (inode.LeftNode is IdentifierNode)
                {
                    FunctionCallNode getter = EmitGetterSetterForIdent(inode.LeftNode as IdentifierNode, false);
                    inode.LeftNode = getter;
                    return;
                }

                inode = inode.LeftNode as IdentifierListNode;
            }
        }

        private bool IsParsingGlobal()
        {
            return (null == localProcedure) && (ProtoCore.DSASM.ImperativeCompilePass.kGlobalScope == compilePass);
        }

        private bool IsParsingGlobalFunctionBody()
        {
            return (null != localProcedure) && (ProtoCore.DSASM.ImperativeCompilePass.kGlobalFuncBody == compilePass);
        }

        protected override void DfsTraverse(ProtoCore.AST.Node pNode, ref ProtoCore.Type inferedType, bool isBooleanOp = false, ProtoCore.AssociativeGraph.GraphNode graphNode = null, ProtoCore.DSASM.AssociativeSubCompilePass subPass = ProtoCore.DSASM.AssociativeSubCompilePass.kNone)
        {
            ImperativeNode node = pNode as ImperativeNode;
            if (null == node)
                return;

            if (node is IdentifierNode)
            {
                EmitIdentifierNode(node, ref inferedType, isBooleanOp);
            }
            else if (node is IntNode)
            {
                EmitIntNode(node, ref inferedType, isBooleanOp);
            }
            else if (node is DoubleNode)
            {
                EmitDoubleNode(node, ref inferedType, isBooleanOp);
            }
            else if (node is BooleanNode)
            {
                EmitBooleanNode(node, ref inferedType);
            }
            else if (node is CharNode)
            {
                EmitCharNode(node, ref inferedType);
            }
            else if (node is StringNode)
            {
                EmitStringNode(node, ref inferedType);
            }
            else if (node is NullNode)
            {
                EmitNullNode(node, ref inferedType, isBooleanOp);
            }
#if ENABLE_INC_DEC_FIX
            else if (node is PostFixNode)
            {
                EmitPostFixNode(node, ref inferedType);
            }
#endif
            else if (node is ReturnNode)
            {
                EmitReturnNode(node);
            }
            else if (node is LanguageBlockNode)
            {
                EmitLanguageBlockNode(node, ref inferedType);
            }
            else if (node is ConstructorDefinitionNode)
            {
                EmitConstructorDefinitionNode(node);
            }
            else if (node is FunctionDefinitionNode)
            {
                EmitFunctionDefinitionNode(node, ref inferedType);
            }
            else if (node is FunctionCallNode)
            {
                EmitFunctionCallNode(node, ref inferedType, isBooleanOp);
            }
            else if (node is IfStmtNode)
            {
                EmitIfStmtNode(node, ref inferedType);
            }
            else if (node is WhileStmtNode)
            {
                EmitWhileStmtNode(node, ref inferedType);
            }
            else if (node is VarDeclNode)
            {
                EmitVarDeclNode(node, ref inferedType);
            }
            else if (node is ExprListNode)
            {
                EmitExprListNode(node, ref inferedType);
            }
            else if (node is IdentifierListNode)
            {
                EmitIdentifierListNode(node, ref inferedType, isBooleanOp);
            }
            else if (node is BinaryExpressionNode)
            {
                EmitBinaryExpressionNode(node, ref inferedType, isBooleanOp);
            }
            else if (node is UnaryExpressionNode)
            {
                EmitUnaryExpressionNode(node, ref inferedType);
            }
            else if (node is ForLoopNode)
            {
                EmitForLoopNode(node);
            }
            else if (node is InlineConditionalNode)
            {
                EmitInlineConditionalNode(node, ref inferedType);
            }
            else if (node is RangeExprNode)
            {
                EmitRangeExprNode(node, ref inferedType);
            }
            else if (node is BreakNode)
            {
                EmitBreakNode(node);
            }
            else if (node is ContinueNode)
            {
                EmitContinueNode(node);
            }
            else if (node is DefaultArgNode)
            {

            }
            else if (node is ExceptionHandlingNode)
            {
                EmitExceptionHandlingNode(node);
            }
            else if (node is ThrowNode)
            {
                EmitThrowNode(node);
            }
        }
    }
}
