
COMPILER DesignScriptParser

    public Node root { get; set; }
    public CodeBlockNode commentNode { get; set; }
    public ProtoFFI.ImportModuleHandler ImportModuleHandler { get; set; }
    
    //used for isModifier check
    private string leftVar { get; set; }
    private bool isModifier = false;
    private bool withinModifierCheckScope = false;
    private bool isLeftVarIdentList = false;
    //end

    private int localVarCount = 0;
    private bool isGlobalScope = true;

    private bool isInClass = false;
    private bool disableKwCheck = false;

    private bool isLeft = false; // check if it is left hand side of the assignment expression

    // This is used by GraphIDE mode parsing when determining how many statements the parser has processed
    private int stmtsParsed = 0;


    private static string GetEscapedString(string s)
    {
        System.Text.StringBuilder sb = new System.Text.StringBuilder();

        int i = 0;
        while (i < s.Length)
        {
            if (s[i] == '\\' && (i + 1) < s.Length)
            {
                i = i + 1;
                switch (s[i])
                {
                    case '\\':
                        sb.Append('\\');
                        break;
                    case '"':
                        sb.Append('"');
                        break;
                    case 'a':
                        sb.Append('\a');
                        break;
                    case 'b':
                        sb.Append('\b');
                        break;
                    case 'f':
                        sb.Append('\f');
                        break;
                    case 'n':
                        sb.Append('\n');
                        break;
                    case 'r':
                        sb.Append('\r');
                        break;
                    case 't':
                        sb.Append('\t');
                        break;
                    case 'v':
                        sb.Append('\v');
                        break;
                    case '0':
                        sb.Append('\0');
                        break;
                    default:
                        i = i - 1;
                        sb.Append(s[i]);
                        break;
                }
            }
            else
            {
                sb.Append(s[i]);
            }
            i = i + 1;
        }
        return sb.ToString();
    }

    
    public List<Node> GetParsedASTList(ProtoCore.AST.AssociativeAST.CodeBlockNode codeBlockNode)
    {
        Validity.Assert(null != codeBlockNode);
        List<Node> astNodes = new List<Node>();
        for (int n = 0; n < stmtsParsed; n++)
        {
            astNodes.Add(codeBlockNode.Body[n]);
        }
        return astNodes;
    }

    private bool IsIdentList()
    {
        Token pt = la;
        if (_ident == pt.kind)
        {
            pt = scanner.Peek();
            if ("." == pt.val)
            {
                pt = scanner.Peek();
                scanner.ResetPeek();
                if (_ident == pt.kind)
                    return true;
            }
        }
        scanner.ResetPeek();
        return false;
    }

	private bool IsModifierStack()
	{
		Token pt = la;
		if(pt.val != "{")
		{
			scanner.ResetPeek();
			return false;
		}

		int counter = 1;
		pt = scanner.Peek();
		while(counter != 0 && pt.kind != _EOF)
		{
			if(pt.val == "{")
				counter++;
			else if(pt.val == "}")
				counter--;

			if(pt.val == ";" && counter == 1)
			{
				scanner.ResetPeek();
				return true;
			}

			pt = scanner.Peek();
		}
		
		scanner.ResetPeek();
		return false;
	}

    private bool IsFunctionCall()
    {
        Token pt = la;
        if( _ident == pt.kind ) 
        {
            pt = scanner.Peek();
            scanner.ResetPeek();
            if( _openparen == pt.kind ) {
                return true;
            }
        }
        scanner.ResetPeek();
        return false;
    }

	private bool IsFunctionCallStatement()
	{
        Token pt = la;
        while (pt.kind != _EOF)
        {
			if( _ident == pt.kind ) 
			{
				pt = scanner.Peek();
				if( _openparen == pt.kind )
				{
					scanner.ResetPeek();
					return true;
				}
				else if( _period == pt.kind )
				{
					pt = scanner.Peek();
					continue;
				}
			}
			else
			{
				break;
			}			
		}

        scanner.ResetPeek();
        return false;
	}

    private bool IsAssignmentStatement()
    {
        Token pt = la;
        while (pt.kind != _EOF)
        {
            if (pt.val == ";")
            {
                scanner.ResetPeek();
                return false;
            }
            else if (pt.val == "=")
            {
                scanner.ResetPeek();
                return true;
            }

            pt = scanner.Peek();
        }

        scanner.ResetPeek();
        return false;
    }

    private bool IsVariableDeclaration()
    {
        Token t = la;
        if (_ident == t.kind) {
            t = scanner.Peek();
            if (":" == t.val) {
                t = scanner.Peek();
                if (_ident == t.kind) {
                    t = scanner.Peek();
                    scanner.ResetPeek();
                    return (_endline == t.kind || "[" == t.val);
                }
                scanner.ResetPeek();
                return false;
            }
            else if (_endline == t.kind) {
                scanner.ResetPeek();
                return true;
            }

            scanner.ResetPeek();
            return false;
        }
        return false;
    }
   
    private bool IsReplicationGuide()
    {
        Token pt = la;
        if( _lessthan == pt.kind ) 
        {
            pt = scanner.Peek();
            if( _number == pt.kind ) 
            {
                pt = scanner.Peek();
                scanner.ResetPeek();
                if( _greaterthan == pt.kind ) 
                {
                    return true;
                }
            }
        }
        scanner.ResetPeek();
        return false;
    }

    private bool IsNumber()
    {
        Token pt = la;

        if (pt.val == "-") {
            pt = scanner.Peek();
            scanner.ResetPeek();
        }

        return ((_number == pt.kind) || (_float == pt.kind));
    }

    private bool IsTypedVariable()
    {
        Token pt = la;

        if (_ident == pt.kind) {
            pt = scanner.Peek();
            scanner.ResetPeek();
            if (":" == pt.val) 
                return true;
        }
        scanner.ResetPeek();
        return false;
    }
	
	private bool IsFullClosure()
    {
        Token pt = la;
        int closureCount = 0;

        while (true)
        {
            pt = scanner.Peek();
            if (pt.val == "(") { closureCount++; continue; }
            if (pt.val == ")") { closureCount--; continue; }
			if ((pt.kind == 0)||(pt.kind == _endline)) break;
		}
        scanner.ResetPeek();
        return (closureCount > 0) ? false : true;
    }

    private bool HasMoreAssignmentStatements()
    {
        Token pt = la;

        if (pt.kind != _ident)
            return false;

        bool gotAssignmentToken = false;
        bool isAssignmentStatement = false;

        while (true) {
            pt = scanner.Peek();
            if (pt.kind == 0) {
                break;
            }
            else if (pt.val == "=") {
                isAssignmentStatement = true;
                break;
            }
            else if (pt.kind == _endline) {
                isAssignmentStatement = gotAssignmentToken;
                break;
            }
            else if (pt.val == "{")
                break;
        }

        scanner.ResetPeek();
        return isAssignmentStatement;
    }

    private string GetImportedModuleFullPath(string moduleLocation)
    {
        string fileName = moduleLocation.Replace("\"", String.Empty);
        string filePath = FileUtils.GetDSFullPathName(fileName, core.Options);

        if (File.Exists(filePath))
            return filePath;

        SemErr(@"Cannot import file: '" + fileName + @"': No such file or directory");
        return null;
    }

    private bool NotDefaultArg()
    {
        Token pt = la;          
        if (pt.val == ",")
            pt = scanner.Peek();
        //pt should be ident now
        if (pt.kind == _ident)
        {         
            pt = scanner.Peek();    //':'
            if (pt.val == ":")
            {
                pt = scanner.Peek();    //type
                if (pt.kind == _ident)
                {
                    pt = scanner.Peek();
                    scanner.ResetPeek();
                    if (pt.val == "=")
                         return false;
                }
            }
			if (pt.val == "=")
			{
				scanner.ResetPeek();
				return false;
			}
        }
        scanner.ResetPeek();        
        return true;    
    }

    private void InsertDotMethod()
    {
        //InsertDotMemVarMethod();
        InsertDotMemFuncMethod();
    }

    ProtoCore.AST.AssociativeAST.IdentifierNode BuildAssocIdentifier(string name, ProtoCore.PrimitiveType type = ProtoCore.PrimitiveType.kTypeVar)
    {
        var ident = new ProtoCore.AST.AssociativeAST.IdentifierNode();
        ident.Name = ident.Value = name;
        ident.datatype = core.TypeSystem.BuildTypeObject(type, false);
        return ident;
    }

    ProtoCore.AST.ImperativeAST.IdentifierNode BuildImperativeIdentifier(string name, ProtoCore.PrimitiveType type = ProtoCore.PrimitiveType.kTypeVar)
    {
        var ident = new ProtoCore.AST.ImperativeAST.IdentifierNode();
        ident.Name = ident.Value = name;
        ident.datatype = core.TypeSystem.BuildTypeObject(type, false);
        return ident;
    }

    private void InsertDotMemVarMethod()
    {
        ProtoCore.AST.AssociativeAST.FunctionDefinitionNode funcDefNode = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode();
        funcDefNode.access = ProtoCore.DSASM.AccessSpecifier.kPublic;
        funcDefNode.Name = ProtoCore.DSASM.Constants.kDotArgMethodName;
        funcDefNode.ReturnType = new ProtoCore.Type() { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeVar), UID = (int)PrimitiveType.kTypeVar };
        ProtoCore.AST.AssociativeAST.ArgumentSignatureNode args = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode();
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kLHS),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeVar), UID = (int)PrimitiveType.kTypeVar }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kRHS), 
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeInt), UID = (int)PrimitiveType.kTypeInt }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%rhsDimExprList"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeInt), UID = (int)PrimitiveType.kTypeInt, IsIndexable = true, rank = 1 }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%rhsDim"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeInt), UID = (int)PrimitiveType.kTypeInt }
        });
        funcDefNode.Singnature = args;

        ProtoCore.AST.AssociativeAST.CodeBlockNode body = new ProtoCore.AST.AssociativeAST.CodeBlockNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode _return = BuildAssocIdentifier(ProtoCore.DSDefinitions.Kw.kw_return, ProtoCore.PrimitiveType.kTypeReturn);

        ProtoCore.AST.AssociativeAST.DotFunctionBodyNode dotNode = new ProtoCore.AST.AssociativeAST.DotFunctionBodyNode(args.Arguments[0].NameNode, args.Arguments[1].NameNode, args.Arguments[2].NameNode, args.Arguments[3].NameNode);
        body.Body.Add(new ProtoCore.AST.AssociativeAST.BinaryExpressionNode() { LeftNode = _return, Optr = ProtoCore.DSASM.Operator.assign, RightNode = dotNode});
        funcDefNode.FunctionBody = body;
        (root as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(funcDefNode); 
    }

    private void InsertDotMemFuncMethod()
    {
        ProtoCore.AST.AssociativeAST.FunctionDefinitionNode funcDefNode = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode();
        funcDefNode.access = ProtoCore.DSASM.AccessSpecifier.kPublic;
        funcDefNode.Name = ProtoCore.DSASM.Constants.kDotArgMethodName;
        funcDefNode.IsBuiltIn = true;
        funcDefNode.ReturnType = new ProtoCore.Type() { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeVar), UID = (int)PrimitiveType.kTypeVar,
        rank = DSASM.Constants.kArbitraryRank, IsIndexable = true};

        ProtoCore.AST.AssociativeAST.ArgumentSignatureNode args = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode();
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kLHS),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeVar), UID = (int)PrimitiveType.kTypeVar }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kRHS),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeInt), UID = (int)PrimitiveType.kTypeInt }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%rhsDimExprList"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeVar), UID = (int)PrimitiveType.kTypeVar, IsIndexable = true, rank = ProtoCore.DSASM.Constants.kArbitraryRank }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%rhsDim"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeInt), UID = (int)PrimitiveType.kTypeInt }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%rhsArgList"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeVar), UID = (int)PrimitiveType.kTypeVar, IsIndexable = true, rank = ProtoCore.DSASM.Constants.kArbitraryRank }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%rhsArgNum"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)PrimitiveType.kTypeInt), UID = (int)PrimitiveType.kTypeInt }
        });
        funcDefNode.Singnature = args;

        ProtoCore.AST.AssociativeAST.CodeBlockNode body = new ProtoCore.AST.AssociativeAST.CodeBlockNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode _return = BuildAssocIdentifier(ProtoCore.DSDefinitions.Kw.kw_return, ProtoCore.PrimitiveType.kTypeReturn);

        ProtoCore.AST.AssociativeAST.DotFunctionBodyNode dotNode = new ProtoCore.AST.AssociativeAST.DotFunctionBodyNode(args.Arguments[0].NameNode, args.Arguments[1].NameNode, args.Arguments[2].NameNode, args.Arguments[3].NameNode, args.Arguments[4].NameNode, args.Arguments[5].NameNode);
        body.Body.Add(new ProtoCore.AST.AssociativeAST.BinaryExpressionNode() { LeftNode = _return, Optr = ProtoCore.DSASM.Operator.assign, RightNode = dotNode});
        funcDefNode.FunctionBody = body;
        (root as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(funcDefNode); 
    }
 

    private void InsertBinaryOperationMethod(Operator op, PrimitiveType r, PrimitiveType op1, PrimitiveType op2, int retRank = 0, int op1rank = 0, int op2rank = 0)
    {
        ProtoCore.AST.AssociativeAST.FunctionDefinitionNode funcDefNode = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode();
        funcDefNode.access = ProtoCore.DSASM.AccessSpecifier.kPublic;
        funcDefNode.IsAssocOperator = true;
        funcDefNode.IsBuiltIn = true;
        funcDefNode.Name = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString();
        funcDefNode.ReturnType = new ProtoCore.Type() { Name = core.TypeSystem.GetType((int)r), UID = (int)r, rank = retRank, IsIndexable = (retRank > 0)};
        ProtoCore.AST.AssociativeAST.ArgumentSignatureNode args = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode();
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kLHS),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)op1), UID = (int)op1, rank = op1rank, IsIndexable = (op1rank > 0)}
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kRHS),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)op2), UID = (int)op2, rank = op2rank, IsIndexable = (op2rank > 0)}
        });
        funcDefNode.Singnature = args;

        ProtoCore.AST.AssociativeAST.CodeBlockNode body = new ProtoCore.AST.AssociativeAST.CodeBlockNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode _return = BuildAssocIdentifier(ProtoCore.DSDefinitions.Kw.kw_return, ProtoCore.PrimitiveType.kTypeReturn);

        ProtoCore.AST.AssociativeAST.IdentifierNode lhs = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kLHS);
        ProtoCore.AST.AssociativeAST.IdentifierNode rhs = BuildAssocIdentifier(ProtoCore.DSASM.Constants.kRHS);
        body.Body.Add(new ProtoCore.AST.AssociativeAST.BinaryExpressionNode() { LeftNode = _return, Optr = ProtoCore.DSASM.Operator.assign, RightNode = new ProtoCore.AST.AssociativeAST.BinaryExpressionNode() { LeftNode = lhs, RightNode = rhs, Optr = op } });
        funcDefNode.FunctionBody = body;
        (root as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(funcDefNode);
    }

	// The following methods are used to insert methods to the bottom of the AST and convert operator to these method calls 
	// to support replication on operators 
	private void InsertUnaryOperationMethod(UnaryOperator op, PrimitiveType r, PrimitiveType operand)
    {
        ProtoCore.AST.AssociativeAST.FunctionDefinitionNode funcDefNode = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode();
        funcDefNode.access = ProtoCore.DSASM.AccessSpecifier.kPublic;
        funcDefNode.IsAssocOperator = true;
        funcDefNode.IsBuiltIn = true;
        funcDefNode.Name = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString();
        funcDefNode.ReturnType = new ProtoCore.Type() { Name = core.TypeSystem.GetType((int)r), UID = (int)r };
        ProtoCore.AST.AssociativeAST.ArgumentSignatureNode args = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode();
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%param"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)operand), UID = (int)operand }
        });
        funcDefNode.Singnature = args;

        ProtoCore.AST.AssociativeAST.CodeBlockNode body = new ProtoCore.AST.AssociativeAST.CodeBlockNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode _return = BuildAssocIdentifier(ProtoCore.DSDefinitions.Kw.kw_return, ProtoCore.PrimitiveType.kTypeReturn);
        ProtoCore.AST.AssociativeAST.IdentifierNode param = BuildAssocIdentifier("%param");
        body.Body.Add(new ProtoCore.AST.AssociativeAST.BinaryExpressionNode() { LeftNode = _return, Optr = ProtoCore.DSASM.Operator.assign, RightNode = new ProtoCore.AST.AssociativeAST.UnaryExpressionNode() { Expression = param, Operator = op } });
        funcDefNode.FunctionBody = body;
        (root as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(funcDefNode);
    }

	private void InsertInlineConditionOperationMethod(PrimitiveType condition, PrimitiveType r)
    {
        ProtoCore.AST.AssociativeAST.FunctionDefinitionNode funcDefNode = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode();
        funcDefNode.access = ProtoCore.DSASM.AccessSpecifier.kPublic;
        funcDefNode.Name = ProtoCore.DSASM.Constants.kInlineCondition; 
        funcDefNode.ReturnType = new ProtoCore.Type() { Name = core.TypeSystem.GetType((int)r), UID = (int)r };
        ProtoCore.AST.AssociativeAST.ArgumentSignatureNode args = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode();
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%condition"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)condition), UID = (int)condition }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%trueExp"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)r), UID = (int)r }
        });
        args.AddArgument(new ProtoCore.AST.AssociativeAST.VarDeclNode()
        {
            memregion = ProtoCore.DSASM.MemoryRegion.kMemStack,
            access = ProtoCore.DSASM.AccessSpecifier.kPublic,
            NameNode = BuildAssocIdentifier("%falseExp"),
            ArgumentType = new ProtoCore.Type { Name = core.TypeSystem.GetType((int)r), UID = (int)r }
        });
        funcDefNode.Singnature = args;

        ProtoCore.AST.AssociativeAST.CodeBlockNode body = new ProtoCore.AST.AssociativeAST.CodeBlockNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode _return = BuildAssocIdentifier(ProtoCore.DSDefinitions.Kw.kw_return, ProtoCore.PrimitiveType.kTypeReturn);
        ProtoCore.AST.AssociativeAST.IdentifierNode con = BuildAssocIdentifier("%condition");
        ProtoCore.AST.AssociativeAST.IdentifierNode t = BuildAssocIdentifier("%trueExp");
        ProtoCore.AST.AssociativeAST.IdentifierNode f = BuildAssocIdentifier("%falseExp");

        body.Body.Add(new ProtoCore.AST.AssociativeAST.BinaryExpressionNode() { LeftNode = _return, Optr = Operator.assign, RightNode = new ProtoCore.AST.AssociativeAST.InlineConditionalNode() { ConditionExpression = con, TrueExpression = t, FalseExpression = f } });
        funcDefNode.FunctionBody = body;
        (root as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(funcDefNode);
    }

	private void InsertPredefinedMethod()
	{
        if (!builtinMethodsLoaded)
        {
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeString, PrimitiveType.kTypeChar, PrimitiveType.kTypeChar);

            
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeString, PrimitiveType.kTypeString, PrimitiveType.kTypeString);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeVar, PrimitiveType.kTypeString, PrimitiveType.kTypeChar);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeVar, PrimitiveType.kTypeChar, PrimitiveType.kTypeString);
//			InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeString, PrimitiveType.kTypeString, PrimitiveType.kTypeVar);
//          InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeString, PrimitiveType.kTypeVar, PrimitiveType.kTypeString);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeString, PrimitiveType.kTypeString, PrimitiveType.kTypeVar, 0, 0, ProtoCore.DSASM.Constants.kArbitraryRank);
            InsertBinaryOperationMethod(Operator.add, PrimitiveType.kTypeString, PrimitiveType.kTypeVar, PrimitiveType.kTypeString,0,ProtoCore.DSASM.Constants.kArbitraryRank,0);

            InsertBinaryOperationMethod(Operator.sub, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.sub, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.sub, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.sub, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            //InsertBinaryOperationMethod(Operator.div, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            //InsertBinaryOperationMethod(Operator.div, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt);
            //InsertBinaryOperationMethod(Operator.div, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.div, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.mul, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.mul, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.mul, PrimitiveType.kTypeDouble, PrimitiveType.kTypeInt, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.mul, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.mod, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);

            InsertBinaryOperationMethod(Operator.bitwiseand, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.bitwiseand, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);
            InsertBinaryOperationMethod(Operator.bitwiseor, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.bitwiseor, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);
            InsertBinaryOperationMethod(Operator.bitwisexor, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.bitwisexor, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);

            InsertBinaryOperationMethod(Operator.eq, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.eq, PrimitiveType.kTypeBool, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.eq, PrimitiveType.kTypeBool, PrimitiveType.kTypeString, PrimitiveType.kTypeString);
			InsertBinaryOperationMethod(Operator.eq, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);
			InsertBinaryOperationMethod(Operator.eq, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeVar);
            InsertBinaryOperationMethod(Operator.eq, PrimitiveType.kTypeBool, PrimitiveType.kTypeVar, PrimitiveType.kTypeBool);
			
            InsertBinaryOperationMethod(Operator.nq, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.nq, PrimitiveType.kTypeBool, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.nq, PrimitiveType.kTypeBool, PrimitiveType.kTypeString, PrimitiveType.kTypeString);
			InsertBinaryOperationMethod(Operator.nq, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);
			InsertBinaryOperationMethod(Operator.nq, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeVar);
            InsertBinaryOperationMethod(Operator.nq, PrimitiveType.kTypeBool, PrimitiveType.kTypeVar, PrimitiveType.kTypeBool);

            InsertBinaryOperationMethod(Operator.ge, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.ge, PrimitiveType.kTypeBool, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.gt, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.gt, PrimitiveType.kTypeBool, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.le, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.le, PrimitiveType.kTypeBool, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.lt, PrimitiveType.kTypeBool, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertBinaryOperationMethod(Operator.lt, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.and, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertBinaryOperationMethod(Operator.or, PrimitiveType.kTypeBool, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);

            InsertUnaryOperationMethod(UnaryOperator.Neg, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertUnaryOperationMethod(UnaryOperator.Neg, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertUnaryOperationMethod(UnaryOperator.Negate, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertUnaryOperationMethod(UnaryOperator.Negate, PrimitiveType.kTypeDouble, PrimitiveType.kTypeDouble);
            InsertUnaryOperationMethod(UnaryOperator.Not, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);

            InsertBinaryOperationMethod(Operator.and, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);
            InsertBinaryOperationMethod(Operator.or, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool, PrimitiveType.kTypeBool);

            InsertUnaryOperationMethod(UnaryOperator.Decrement, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
            InsertUnaryOperationMethod(UnaryOperator.Increment, PrimitiveType.kTypeInt, PrimitiveType.kTypeInt);
        }
	}

	private ProtoCore.AST.AssociativeAST.AssociativeNode GenerateBinaryOperatorMethodCallNode(Operator op, ProtoCore.AST.AssociativeAST.AssociativeNode op1, ProtoCore.AST.AssociativeAST.AssociativeNode op2)
    {
        ProtoCore.AST.AssociativeAST.FunctionCallNode funCallNode = new ProtoCore.AST.AssociativeAST.FunctionCallNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode funcName = new ProtoCore.AST.AssociativeAST.IdentifierNode { Value = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString(), Name = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString() };
        funCallNode.Function = funcName;
        funCallNode.Name = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString();
        funCallNode.FormalArguments.Add(op1); funCallNode.FormalArguments.Add(op2);

        NodeUtils.SetNodeLocation(funCallNode, op1, op2);
        return funCallNode;
    }

	private ProtoCore.AST.AssociativeAST.AssociativeNode GenerateUnaryOperatorMethodCallNode(UnaryOperator op, ProtoCore.AST.AssociativeAST.AssociativeNode operand)
    {
        ProtoCore.AST.AssociativeAST.FunctionCallNode funCallNode = new ProtoCore.AST.AssociativeAST.FunctionCallNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode funcName = new ProtoCore.AST.AssociativeAST.IdentifierNode { Value = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString(), Name = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString() };
        funCallNode.Function = funcName;
        funCallNode.Name = ProtoCore.DSASM.Constants.kInternalNamePrefix + op.ToString();
        funCallNode.FormalArguments.Add(operand);

        NodeUtils.CopyNodeLocation(funCallNode, operand);
        return funCallNode;
    }

	private ProtoCore.AST.AssociativeAST.AssociativeNode GenerateInlineConditionMethodCallNode(ProtoCore.AST.AssociativeAST.AssociativeNode con, ProtoCore.AST.AssociativeAST.AssociativeNode t, ProtoCore.AST.AssociativeAST.AssociativeNode f)
    {
        ProtoCore.AST.AssociativeAST.FunctionCallNode funCallNode = new ProtoCore.AST.AssociativeAST.FunctionCallNode();
        ProtoCore.AST.AssociativeAST.IdentifierNode funcName = new ProtoCore.AST.AssociativeAST.IdentifierNode { Value = ProtoCore.DSASM.Constants.kInlineCondition, Name = ProtoCore.DSASM.Constants.kInlineCondition };
        funCallNode.Function = funcName;
        funCallNode.Name = ProtoCore.DSASM.Constants.kInlineCondition;
        funCallNode.FormalArguments.Add(con);
        funCallNode.FormalArguments.Add(t);
        funCallNode.FormalArguments.Add(f);

        NodeUtils.SetNodeLocation(funCallNode, con, f);
        return funCallNode;
    }

	private void InsertBuiltInMethods()
    {
        if (!builtinMethodsLoaded)
        {
            ProtoCore.Lang.BuiltInMethods builtInMethods = new Lang.BuiltInMethods(core);
            foreach (ProtoCore.Lang.BuiltInMethods.BuiltInMethod method in builtInMethods.Methods)
			{
				(root as ProtoCore.AST.AssociativeAST.CodeBlockNode).Body.Add(GenerateBuiltInMethodSignatureNode(method));
			}
		}
    }

    private ProtoCore.AST.AssociativeAST.FunctionDefinitionNode GenerateBuiltInMethodSignatureNode(ProtoCore.Lang.BuiltInMethods.BuiltInMethod method)
    {
        ProtoCore.AST.AssociativeAST.FunctionDefinitionNode fDef = new ProtoCore.AST.AssociativeAST.FunctionDefinitionNode();
        fDef.Name = method.Name;
        fDef.ReturnType = method.ReturnType;
        fDef.IsExternLib = true;
        fDef.IsBuiltIn = true;
        fDef.BuiltInMethodId = method.ID;
        fDef.Singnature = new ProtoCore.AST.AssociativeAST.ArgumentSignatureNode();

        foreach (KeyValuePair<string, ProtoCore.Type> param in method.Parameters)
        {
            ProtoCore.AST.AssociativeAST.VarDeclNode arg = new ProtoCore.AST.AssociativeAST.VarDeclNode();
            arg.NameNode = new ProtoCore.AST.AssociativeAST.IdentifierNode { Name = param.Key, Value = param.Key };
            arg.ArgumentType = param.Value;
            fDef.Singnature.AddArgument(arg);
        }

        return fDef;
    }

    private bool IsKeyWord(string identName, bool checkReturn = false, bool checkThis = true)
    {
        if (identName == ProtoCore.DSDefinitions.Kw.kw_return && !checkReturn)
        {
            return false;
        }

        if (checkThis && identName == ProtoCore.DSDefinitions.Kw.kw_this)
        {
            return true;
        }

        foreach (string kw in ProtoCore.DSDefinitions.Kw.kwList)
        {
            if (kw == identName)
                return true;
        }
        return false;
    }

	 private bool IsLanguageBlockProperty()
	 {
		Token t = scanner.Peek();
		scanner.ResetPeek();
		if (t.val == "=")
			return true;
		else
			return false;
	 }

	 // use by associative
	 private bool IsNotAttributeFunctionClass()
	 {
		if (la.val == "[")
		{
		    Token t = scanner.Peek();
            while (t.val != "]" && t.kind != _EOF)
            {
                t = scanner.Peek();
            }
          
            if (t.val == "]")
            {
                Token next = scanner.Peek(); 
                scanner.ResetPeek();
                return (next.val == "{");
            }
            else
            {
                scanner.ResetPeek();
                return false;
            }
		}

		if (la.kind != _kw_class && la.kind != _kw_def && la.kind != _kw_external)
			return true;
		return false;
	 }

	 // used by imperative
	 private bool IsNotAttributeFunction()
	 {
	    if (la.val == "[")
		{
		    Token t = scanner.Peek();
            while (t.val != "]" && t.kind != _EOF)
            {
                t = scanner.Peek();
            }
          
            if (t.val == "]")
            {
                Token next = scanner.Peek(); 
                scanner.ResetPeek();
                return (next.val == "{");
            }
            else
            {
                scanner.ResetPeek();
                return false;
            }
		}

		if (la.kind != _kw_external && la.kind != _kw_def)
			return true;
		return false;
	 }

	 
	 //Experiment for user-defined synErr message
	 private void SynErr (string s) {
		if (errDist >= minErrDist) 
		core.BuildStatus.LogSyntaxError(s, core.CurrentDSFileName, la.line, la.col);
		errors.count++;
		errDist = 0;
	 }


CHARACTERS

    uppercaseletter = 'A'..'Z'.
    lowercaseletter = 'a'..'z'.
    letter = uppercaseletter + lowercaseletter.
    digit = '0'..'9'.
    cr  = '\r'. 
    lf  = '\n'.
    tab = '\t'.
    anyButDoubleQuote = ANY - '\"'.
    anyButQuote = ANY - '\''.
    anychar = ANY.
    other = ANY - '/' - '*'.
    anyExcludingEndOfLine = ANY - lf.

TOKENS
    ident = (letter | '_' | '@'){letter | digit | '_' | '@'}.
    number = digit {digit} .
    float = digit {digit} '.' digit {digit} [('E' | 'e') ['+'|'-'] digit {digit}].
    textstring = '"' {anyButDoubleQuote | "\\\""} '"'.
    char = '\'' (anyButQuote | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" | "\\u") '\''.
    period = '.'.

    openbracket = '['.
    closebracket = ']'.
    openparen = '('.
    closeparen = ')'.

    not = '!'.
    neg = '-'.
    pipe = '|'.
    lessthan = '<'.
    greaterthan = '>'.
    lessequal = "<=".
    greaterequal = ">=".
    equal = "==".
    notequal = "!=".
    endline = ';'.
    rangeop = "..".

    kw_native = "native".
    kw_class = "class".
    kw_constructor = "constructor".
    kw_def = "def".
    kw_external = "external".
    kw_extend = "extends".
    kw_heap = "__heap".
    kw_if = "if".
    kw_elseif = "elseif".
    kw_else = "else".
    kw_while = "while".
    kw_for = "for".
    kw_import = "import".
    kw_prefix = "prefix".
    kw_from = "from".
    kw_break = "break".
    kw_continue = "continue".
    kw_static = "static".

    literal_true = "true".
    literal_false = "false".
    literal_null = "null".

//COMMENTS FROM "/*" TO "*/" 
//COMMENTS FROM "//" TO lf

PRAGMAS

    inlinecomment =  "//" {anyExcludingEndOfLine}.			(. 
                                                                   CommentNode cNode = new CommentNode(la.col, la.line, la.val, CommentNode.CommentType.Inline); 
                                                                   commentNode.Body.Add(cNode); .)
    blockcomment = "/*" {'/' | other | '*' {'*'} other} '*' {'*'} '/'. (.
                                                             CommentNode cNode = new CommentNode(la.col, la.line, la.val, CommentNode.CommentType.Block); 
                                                             commentNode.Body.Add(cNode); .)

IGNORE cr + lf + tab

PRODUCTIONS
//-----------------------------InsertPredefinedAndBuiltinMethods-----------------//
InsertPredefinedAndBuiltinMethods<Node node>
= 
(. 
                                root = node; 
                                if (DSASM.InterpreterMode.kNormal == core.ExecMode)
                                {
                                    if (!builtinMethodsLoaded)
                                    {
                                        InsertDotMethod();
                                    }
                                    if (core.Options.AssocOperatorAsMethod)
                                    {
                                        InsertPredefinedMethod();
                                    }
                                    InsertBuiltInMethods();
                                }
                            
                            .)    
                            .
//-----------------------------DesignScriptParser---------------------------//
DesignScriptParser
=                           (. Node node = null; .)
    Hydrogen<out node>       
        (. if (!core.IsParsingPreloadedAssembly && !core.IsParsingCodeBlockNode)
        { .)

            (
                InsertPredefinedAndBuiltinMethods<node>
            )
        (. 
        }
        else
            root = node;
            .)

.
